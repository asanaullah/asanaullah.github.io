<!DOCTYPE HTML>
<!--
	Projection by TEMPLATED
	templated.co @templatedco
	Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)
-->
<html>
	<head>
		<title>Basic Hardware Generation</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<link rel="stylesheet" href="/assets/css/main.css" />
	</head>
	<body class="subpage">

		<!-- Header -->
			<header id="header">
				<div class="inner" >
					<p  class="logo"> <a href="index.html">Towards a Productive Ecosystem for Targetting Specialized Hardware</a></p>
					<nav id="nav">
						<a style="color:white;font-weight:bold;" href="../../../../index.html">Home</a>
						<a style="color:white;font-weight:bold;" href="../../../../about.html">Overview</a>
						<a style="color:white;font-weight:bold;" href="../../../../ML.html">FPGA ML</a>
						<a style="color:white;font-weight:bold;" href="../../../../HLS.html">High Level Synthesis</a>
						<a style="color:white;font-weight:bold;" href="../../../../MPC.html">Multi Party Computation</a>
						<a style="color:white;font-weight:bold;" href="../../../../PR.html">Partial Reconfiguration</a>
						<a style="color:white;font-weight:bold;" href="../../../../PNR.html">Project PNR</a>
						<a style="color:white;font-weight:bold;" href="../../../../Morpheus.html">Project Morpheus</a>
						<a style="color:white;font-weight:bold;" href="../../../../MemRe.html">Project Mem-Re</a>
						<a style="color:white;font-weight:bold;" href="../../../../RM.html">Relational Memory</a>
						<a style="color:white;font-weight:bold;" href="../../../../SC.html">Softcores</a>
						<a style="color:white;font-weight:bold;" href="../../../../DM.html">Demos</a>
						<a style="color:white;font-weight:bold;" href="../../../../people.html">People</a>
					</nav>
					<a href="#navPanel" class="navPanelToggle"><span class="fa fa-bars"></span></a>
				</div>
			</header>

		<!-- Three -->
			<section  >
					<header class="align-center">
						<h2>An Open Source FPGA Compilation Flow using RapidWright</h2>
					</header>
					<h1 style = "text-align:right; color:black; margin-right:2em; font-weight:bold">04 Jul 2020 - Ahmed Sanaullah</h1>
					<article style="color:black; margin-left:5em; margin-right:5em">
						
						<h2 id="aim">Aim</h2>
<p>In this project, our aim is to use RapidWright to build a basic open source compilation flow for the 7 series Xilinx FPGAs. The flow is not meant to be complete and comprehensive. Rather, it is aimed at providing insights into the hardware generation process.</p>

<h2 id="status">Status</h2>
<ul>
  <li>Synthesis (complete)</li>
  <li>Place and Route (complete)</li>
  <li>Bitstream Generation (fixing bugs in FASM generator for clocking and bi-direction PIPs - currently using Vivado for bitstream generation)</li>
  <li>Bitstream Programming (complete)</li>
</ul>

<h2 id="what-is-rapidwright">What is RapidWright?</h2>
<p>RapidWright is a free tool from Xilinx that contains APIs, Data Structures and device databases needed to implement custom Place &amp; Route algorithms for almost all chips in the vendor family. It is possible to customize the overall flow as well, with developers able to focus on specific parts of P&amp;R and leverage Vivado for the rest. While RapidWright is written in Javascript, it has a built in Python interpreter (Jython) which enables us to use Jupyter Notebook for this project.</p>

<h2 id="limitations">Limitations</h2>
<p>RapidWright has four major limitations that we have encountered thus far:</p>

<ol>
  <li>
    <p>RapidWright is not fully open source. There are certain Classes for which only APIs are exposed, and actual implementation details are not available.</p>
  </li>
  <li>
    <p>RapidWright cannot generate bitstreams. Doing so requires either using Vivado, or a third party tool such as <a href="https://github.com/SymbiFlow/prjxray">Project Xray</a>.</p>
  </li>
  <li>
    <p>Native file support is limited to Vivado compatible files, namely EDIF (logical netlist) and DCP (design checkpoint).</p>
  </li>
  <li>
    <p>There is very little documentation for Classes and APIs beyond a <a href="http://www.rapidwright.io/javadoc/index.html">list</a> of them on the RapidWright website.</p>
  </li>
</ol>

<h2 id="circuit">Circuit</h2>
<p>Our target circuit is shown below. We initially tested the flow using a simple 2 bit adder w/ carry and registered outputs since this design had both combinational and sequential components.</p>

<p>While working on the FASM generator, we added in a “short circuit” i.e. a wire that connects an input port directly to an output port. This was useful for debugging the process of mapping designs to the FPGA’s configuration memory space.</p>

<p><img src="/images/blog/PNR/basic-hardware-generation/target_circuit.PNG" alt="Target circuit that we will implement on an FPGA" /></p>

<h2 id="yosys-synthesis">Yosys (Synthesis)</h2>
<p>For synthesis, we will be using <a href="http://www.clifford.at/yosys/about.html">Yosys</a>.</p>

<h3 id="setting-up-the-environment">Setting Up The Environment</h3>

<p>This is the script we use to build Yosys. Since we are reusing the script from <a href="https://github.com/asanaullah/ZipVersa-SSDP">here</a>, there might be more dependencies installed than needed.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>dnf <span class="nt">-y</span> groupinstall <span class="s2">"Development Tools"</span> <span class="s2">"Development Libraries"</span>
audo dnf <span class="nt">-y</span> <span class="nb">install </span>cmake clang bison flex mercurial gperf tcl-devel libftdi-devel python-xdot graphviz
git clone https://github.com/YosysHQ/yosys.git
<span class="nb">cd </span>yosys
make <span class="nt">-j</span><span class="si">$(</span><span class="nb">nproc</span><span class="si">)</span>
<span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="s2">"</span><span class="nv">$PATH</span><span class="s2">:</span><span class="nv">$PWD</span><span class="s2">/yosys"</span>
</code></pre></div></div>
<p>or on a Fedora machine:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>dnf <span class="nb">install </span>yosys
</code></pre></div></div>

<p>Once Yosys is set up, the <code class="highlighter-rouge">synth_xilinx</code> command can be used to synthesize the design for Xilinx 7-series FPGAs. Details of what each option does is given <a href="http://www.clifford.at/yosys/cmd_synth_xilinx.html">here</a>. The full Yosys call is given below.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yosys <span class="nt">-p</span> <span class="s2">"synth_xilinx -flatten -abc9 -nobram -arch xc7 -top top; write_json top.json"</span> 
</code></pre></div></div>

<h3 id="edif-vs-json">EDIF vs JSON</h3>
<p>In the command above, we used the option <code class="highlighter-rouge">write_json</code> to generate the synthesized logical circuit as a JSON file, as opposed to the more common EDIF file (in the context of EDA) which is generated using the <code class="highlighter-rouge">write_edif</code> option. While EDIF is natively supported by RapidWright, it is a fairly restrictive format which limits the design information that can be stored. This typically include only the target technology library, used circuit components and component connectivity. Any additional information will have to be rediscovered by post-synthesis tools, which may not be possible if it requires context that could not be included in the EDIF file. Moreover, this also means that we would need yet another interchange format to store the physical design. By contrast, JSON can store virtually any information due to its permissive format, making it a “universal” interchange format for all stages in the compilation flow. We will have to build a custom JSON reader though, but it is relatively simple to do due to the simplicity of the format.</p>

<p>It is also important to mention here that the Yosys and RapidWright EDIF formats are currently incompatible. Fixing this requires either manually modifying the Yosys EDIF output, or using Vivado to import and rewrite the EDIF file in a RapidWright compatible format.</p>

<h3 id="hdl-code">HDL Code</h3>
<p>The Verilog code for our design is given below. While Yosys will automatically infer IO and global clock buffers, it only inserts the generic <code class="highlighter-rouge">BUFG</code> cell for the global clock buffer. The assumption here is that the Place &amp; Route tools will replace  <code class="highlighter-rouge">BUFG</code> with the actual primitive, <code class="highlighter-rouge">BUFGCTRL</code> in this case. While it is possible to do this using RapidWright, the simpler solution is to manually instantiate a <code class="highlighter-rouge">BUFGCTRL</code> since Yosys does have support for this. This is also done by other open source Place and Route tools, such as in this <a href="https://github.com/daveshah1/nextpnr-xilinx/blob/xilinx-upstream/xilinx/examples/arty-a35/blinky.v">example</a> from Nextpnr.</p>

<p>(Note 1: For clocks, both an IO and a global clock buffer is generated)</p>

<p>(Note 2: If the Yosys EDIF file with <code class="highlighter-rouge">BUFG</code> is imported into Vivado, Vivado will show <code class="highlighter-rouge">BUFG</code> in the logical netlist. When the Vivado placer is run, the <code class="highlighter-rouge">BUFG</code> cell will be placed at a <code class="highlighter-rouge">BUFGCTRL</code> location, but the schematic will continue to show <code class="highlighter-rouge">BUFG</code>)</p>

<div class="language-verilog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="n">top</span><span class="p">(</span>
    <span class="kt">input</span> <span class="n">i_clk</span><span class="p">,</span>
    <span class="kt">input</span> <span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">in0</span><span class="p">,</span>
    <span class="kt">input</span> <span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">in1</span><span class="p">,</span>
    <span class="kt">output</span> <span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">out</span><span class="p">);</span>
    
    <span class="kt">wire</span> <span class="n">clk</span><span class="p">;</span>
    <span class="kt">reg</span> <span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">result</span><span class="p">;</span>
   
    <span class="n">BUFGCTRL</span> <span class="n">clk_buf</span><span class="p">(</span>
        <span class="p">.</span><span class="n">I1</span><span class="p">(</span><span class="mb">1'b0</span><span class="p">),</span>
        <span class="p">.</span><span class="n">I0</span><span class="p">(</span><span class="n">i_clk</span><span class="p">),</span>
        <span class="p">.</span><span class="n">O</span><span class="p">(</span><span class="n">clk</span><span class="p">),</span>
        <span class="p">.</span><span class="n">S0</span><span class="p">(</span><span class="mb">1'b1</span><span class="p">),</span>
        <span class="p">.</span><span class="n">CE0</span><span class="p">(</span><span class="mb">1'b1</span><span class="p">),</span>
        <span class="p">.</span><span class="n">IGNORE0</span><span class="p">(</span><span class="mb">1'b0</span><span class="p">),</span>
        <span class="p">.</span><span class="n">S1</span><span class="p">(</span><span class="mb">1'b0</span><span class="p">),</span>
        <span class="p">.</span><span class="n">CE1</span><span class="p">(</span><span class="mb">1'b0</span><span class="p">),</span>
        <span class="p">.</span><span class="n">IGNORE1</span><span class="p">(</span><span class="mb">1'b0</span><span class="p">)</span>
    <span class="p">);</span>
    
    <span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">clk</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">&lt;=</span> <span class="n">in0</span><span class="o">+</span><span class="n">in1</span><span class="p">;</span>
        
    <span class="k">assign</span> <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
    <span class="k">assign</span> <span class="n">out</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">in1</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    
<span class="k">endmodule</span>
</code></pre></div></div>

<p>The following logical circuit showing the adder only) was generated by Yosys after synthesizing the above code. As could be seen by the circuit connectivity, and confirmed by generating the bitstream using Vivado, the circuit was not correct. This may be because Yosys was unable to translate the behavioral <code class="highlighter-rouge">+</code> operator w/ carry support.</p>

<p><img src="/images/blog/PNR/basic-hardware-generation/schematic_auto_adder.PNG" alt="Circuit generated when compiling the behavioral adder using Yosys" /></p>

<p>To address this, we replaced the <code class="highlighter-rouge">+</code> operator with Boolean logic for each output bit as show below.</p>

<div class="language-verilog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">result</span> <span class="o">&lt;=</span> <span class="o">{</span><span class="p">(</span><span class="n">in1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&amp;</span><span class="n">in0</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">|</span><span class="p">((</span><span class="n">in1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&amp;</span><span class="n">in0</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">&amp;</span><span class="p">(</span><span class="n">in1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">^</span><span class="n">in0</span><span class="p">[</span><span class="mi">1</span><span class="p">])),(</span><span class="n">in1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">^</span><span class="n">in0</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">^</span><span class="p">(</span><span class="n">in1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&amp;</span><span class="n">in0</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">in1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">^</span><span class="n">in0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">}</span><span class="p">;</span>
</code></pre></div></div>

<p>And this does give us the correct adder circuit. We verified it by compiling the above HDL code (w/ <code class="highlighter-rouge">+</code> operator) using Vivado.</p>

<p><img src="/images/blog/PNR/basic-hardware-generation/schematic_manual_adder.PNG" alt="Circuit generated by Yosys when using boolean logic to specify the adder" /></p>

<p>The final Verilog code is thus:</p>

<div class="language-verilog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="n">top</span><span class="p">(</span>
    <span class="kt">input</span> <span class="n">i_clk</span><span class="p">,</span>
    <span class="kt">input</span> <span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">in0</span><span class="p">,</span>
    <span class="kt">input</span> <span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">in1</span><span class="p">,</span>
    <span class="kt">output</span> <span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">out</span><span class="p">);</span>
    
    <span class="kt">wire</span> <span class="n">clk</span><span class="p">;</span>
    <span class="kt">reg</span> <span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">result</span><span class="p">;</span>
   
    <span class="n">BUFGCTRL</span> <span class="n">clk_buf</span><span class="p">(</span>
        <span class="p">.</span><span class="n">I1</span><span class="p">(</span><span class="mb">1'b0</span><span class="p">),</span>
        <span class="p">.</span><span class="n">I0</span><span class="p">(</span><span class="n">i_clk</span><span class="p">),</span>
        <span class="p">.</span><span class="n">O</span><span class="p">(</span><span class="n">clk</span><span class="p">),</span>
        <span class="p">.</span><span class="n">S0</span><span class="p">(</span><span class="mb">1'b1</span><span class="p">),</span>
        <span class="p">.</span><span class="n">CE0</span><span class="p">(</span><span class="mb">1'b1</span><span class="p">),</span>
        <span class="p">.</span><span class="n">IGNORE0</span><span class="p">(</span><span class="mb">1'b0</span><span class="p">),</span>
        <span class="p">.</span><span class="n">S1</span><span class="p">(</span><span class="mb">1'b0</span><span class="p">),</span>
        <span class="p">.</span><span class="n">CE1</span><span class="p">(</span><span class="mb">1'b0</span><span class="p">),</span>
        <span class="p">.</span><span class="n">IGNORE1</span><span class="p">(</span><span class="mb">1'b0</span><span class="p">)</span>
    <span class="p">);</span>
    
    <span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">clk</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">&lt;=</span> <span class="o">{</span><span class="p">(</span><span class="n">in1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&amp;</span><span class="n">in0</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">|</span><span class="p">((</span><span class="n">in1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&amp;</span><span class="n">in0</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">&amp;</span><span class="p">(</span><span class="n">in1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">^</span><span class="n">in0</span><span class="p">[</span><span class="mi">1</span><span class="p">])),(</span><span class="n">in1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">^</span><span class="n">in0</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">^</span><span class="p">(</span><span class="n">in1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&amp;</span><span class="n">in0</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">in1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">^</span><span class="n">in0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">}</span><span class="p">;</span>
        
    <span class="k">assign</span> <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
    <span class="k">assign</span> <span class="n">out</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">in1</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    
<span class="k">endmodule</span>
</code></pre></div></div>

<h2 id="setting-up-the-rapidwright-environment">Setting Up The RapidWright Environment</h2>
<p>A guide for setting up the Jython kernel can be found <a href="https://www.rapidwright.io/docs/RapidWright_Jupyter_Setup.html">here</a></p>

<h2 id="quick-object-reference">Quick Object Reference</h2>
<p>One last thing before diving into the code. There are a lot of well defined objects in RapidWright that we will be using to implement the P&amp;R flow. While the specific role of each object is described in the <a href="https://www.rapidwright.io/docs/index.html">RapidWright documentation</a> (in particular <a href="https://www.rapidwright.io/docs/RapidWright_Overview.html">here</a>) and <a href="http://www.rapidwright.io/javadoc/index.html">API guide</a>, we will list some important ones and provide a brief description for each.</p>

<h3 id="common-objects">Common Objects</h3>

<ol>
  <li><strong>Design</strong> : Responsible for storing all information regarding the logical and physical representations of the design that we are working on. All code we write either updates <strong>Design</strong> directly, or another object that is created within <strong>Design</strong>.</li>
</ol>

<h3 id="objects-that-deal-with-the-logical-netlist">Objects That Deal With The Logical Netlist</h3>

<ol>
  <li>
    <p><strong>EDIFNetlist</strong> : Contains information about the different components in a logical netlist and their connectivity. A <strong>EDIFNetlist</strong> object is automatically created inside a <strong>Design</strong> object.</p>
  </li>
  <li>
    <p><strong>EDIFCell</strong> : This is used to store a logical netlist component. In RapidWright, the overall netlist is also considered a netlist component, and the <strong>EDIFCell</strong> for this is automatically created inside the <strong>EDIFNetlist</strong> object (when the <strong>Design</strong> object is created).</p>
  </li>
  <li>
    <p><strong>EDIFPort</strong> : This is a logical port of the netlist component represented by an <strong>EDIFCell</strong> object.</p>
  </li>
  <li>
    <p><strong>EDIFLibrary</strong> : This is a collection of unique <strong>EDIFCell</strong> objects that are used to build the logical netlist. The specific library we will be building is <code class="highlighter-rouge">hdi_primitives</code>, which (once built) will contain components available in the target technology. This library is automatically created within the <strong>EDIFNetlist</strong> object (and is initially empty).</p>
  </li>
  <li>
    <p><strong>EDIFCellInst</strong> : This is an instance of an <strong>EDIFCell</strong> within another <strong>EDIFCell</strong> object. In a flattened design, only one parent  <strong>EDIFCell</strong> object is created, i.e. the overall logical netlist, and all other <strong>EDIFCell</strong> objects in the <code class="highlighter-rouge">hdi_primitives</code> <strong>EDIFLibrary</strong> are manually instantiated as child <strong>EDIFCellInst</strong> objects in this <strong>EDIFCell</strong></p>
  </li>
  <li>
    <p><strong>EDIFPortInst</strong> : This is a logical port instance of the netlist component represented by an <strong>EDIFCellInst</strong> object.</p>
  </li>
  <li>
    <p><strong>EDIFNet</strong> : An <strong>EDIFNet</strong> object contains all <strong>EDIFPortInst</strong> objects that are connected together in the design. To include an <strong>EDIFPort</strong> in <strong>EDIFNet</strong>, we must first create an <strong>EDIFPortInst</strong> object for it.</p>
  </li>
</ol>

<h3 id="objects-that-deal-with-the-physical-netlist">Objects That Deal With The Physical Netlist</h3>

<ol>
  <li>
    <p><strong>Device</strong> : Contains all information regarding the chip architecture. Each <strong>Design</strong> object must contain a fully defined <strong>Device</strong> object in order to use APIs that require a chip context, such as finding compatable locations for a given component. An empty <strong>Device</strong> object is automatically created inside a <strong>Design</strong> object.</p>
  </li>
  <li>
    <p><strong>Cell</strong> : Contains the physical netlist component for a given <strong>EDIFCellInst</strong> object.</p>
  </li>
  <li>
    <p><strong>BEL</strong> : Represents a Basic Element of Logic (<em>BEL</em>) within the target FPGA. <em>BELs</em> form the lowest level in the device fabric hierarchy, and each <strong>Cell</strong> object maps to a unqiue <em>BEL</em> within the design. Examples of <em>BELs</em> are Look Up Tables (LUTs), D Flip-Flops with Clock Enable and Synchronous Reset (FDREs) and Carry blocks.</p>
  </li>
  <li>
    <p><strong>BELPin</strong> : This represents a pin of a <strong>BEL</strong> object.</p>
  </li>
  <li>
    <p><strong>Site</strong> : Represents a <em>Site</em> within the target FPGA. A <em>Site</em> is effectively a collection of <em>BELs</em> that are hardwired together.</p>
  </li>
  <li>
    <p><strong>SiteWire</strong> : This is not technically a class, but rather a special type of <strong>Wire</strong>. <strong>SiteWire</strong>s represent a wire in a <strong>Site</strong> object that connects two or more <strong>BELPin</strong> objects.</p>
  </li>
  <li>
    <p><strong>SitePIP</strong> : While the wires between <em>BEL</em> pins in a <em>Site</em> are fixed, we can use a special type of <em>BEL</em>, i.e. a Routing <em>BEL</em> (<em>RBEL</em>), to control connectivity between regular <em>BELs</em>; <em>RBELs</em> are essentially MUXs. A <strong>SitePIP</strong> object represents a Input-Ouput pairing of <em>RBEL</em> pins. By “turning on” a <strong>SitePIP</strong>, we can specify which input should an <em>RBEL</em> select, and thus control the flow of data within a <em>Site</em>.</p>
  </li>
  <li>
    <p><strong>SitePin</strong> : This represents a pin of a <strong>Site</strong> object. A <em>Site</em> can have less pins than the total number of pins for all <em>BELs</em> within the <em>Site</em>. This is why efficient Packing is important for large design i.e. so that a number of <em>BEL</em> connections can be made on an intra-Site level (and therefore would not require access to <em>Site</em> pins.</p>
  </li>
  <li>
    <p><strong>Net</strong> : A <strong>Net</strong> object is a collection of <em>Site</em> pins that are connected together, as well the routing resources being used to connect them. Since these routing resources are only connecting <em>Site</em> pins, they do not use <em>Site</em> wires or <em>BELs</em> of <em>Sites</em> that are part of the <strong>Net</strong> object. An exception to this is a “route through”, where (in order to create a shorter path) the routing resources used by a <strong>Net</strong> object can include <em>Site</em> wires and <em>BELs</em> within a <em>Site</em> which is not part of the <strong>Net</strong> object.</p>
  </li>
  <li>
    <p><strong>Wire</strong> : A <strong>Wire</strong> object represents a physical <em>wire</em> on the chip.</p>
  </li>
  <li>
    <p><strong>PIP</strong> :  Programmable Interconnect Points (PIPs) are switches/junctions that can be turn on to connect <em>wires</em> together. <strong>Net</strong> objects contain a list of <strong>PIP</strong> objects to store their routed paths. It is important to note that some <em>PIPs</em> can be bidirectional as well, in which case turning them on is not sufficient - the correct direction of signal transmission must also be specified.</p>
  </li>
  <li>
    <p><strong>RouteNode</strong> : A <strong>RouteNode</strong> object can be created from the RapidWright <a href="https://www.rapidwright.io/javadoc/com/xilinx/rapidwright/router/package-summary.html">Router</a> package. It is useful for keeping track of <em>PIPs</em> visited when traversing a chip’s routing resources.</p>
  </li>
</ol>

<h4 id="to-simplify-our-discussion-in-the-rest-of-this-document-we-will-refer-to-rapidwright-objects-as-object_name-instead-of-object_name-object-"><ins>To simplify our discussion in the rest of this document, we will refer to RapidWright objects as “<strong>Object_Name</strong>” instead of “<strong>Object_Name</strong> object”. </ins></h4>

<p><img src="/images/blog/PNR/basic-hardware-generation/hierarchy.PNG" alt="Simplified hierarchy of objects in RapidWright" /></p>

<h2 id="common-packages">Common Packages</h2>
<p>Let’s start by importing some Classes from commonly used Packages. A brief overview of each Class is given in the <a href="http://www.rapidwright.io/javadoc/index.html">documentation</a>, as well as our quick object reference section above. For simplicity’s sake, we have grouped almost all imported Classes at the beginning, even though they were added as needed during code development.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">com.xilinx.rapidwright.design</span> <span class="kn">import</span> <span class="n">Design</span>
<span class="kn">from</span> <span class="nn">com.xilinx.rapidwright.design</span> <span class="kn">import</span> <span class="n">DesignTools</span>
<span class="kn">from</span> <span class="nn">com.xilinx.rapidwright.design</span> <span class="kn">import</span> <span class="n">NetType</span>
<span class="kn">from</span> <span class="nn">com.xilinx.rapidwright.design</span> <span class="kn">import</span> <span class="n">Unisim</span>
<span class="kn">from</span> <span class="nn">com.xilinx.rapidwright.design</span> <span class="kn">import</span> <span class="n">Module</span>
<span class="kn">from</span> <span class="nn">com.xilinx.rapidwright.design</span> <span class="kn">import</span> <span class="n">SitePinInst</span>
<span class="kn">from</span> <span class="nn">com.xilinx.rapidwright.design</span> <span class="kn">import</span> <span class="n">PinType</span> 
<span class="kn">from</span> <span class="nn">com.xilinx.rapidwright.design</span> <span class="kn">import</span> <span class="n">Net</span> 
<span class="kn">from</span> <span class="nn">com.xilinx.rapidwright.design</span> <span class="kn">import</span> <span class="n">NetType</span>
<span class="kn">from</span> <span class="nn">com.xilinx.rapidwright.design.tools</span> <span class="kn">import</span> <span class="n">LUTTools</span>
<span class="kn">from</span> <span class="nn">com.xilinx.rapidwright.device</span> <span class="kn">import</span> <span class="n">Device</span>
<span class="kn">from</span> <span class="nn">com.xilinx.rapidwright.device</span> <span class="kn">import</span> <span class="n">Site</span>
<span class="kn">from</span> <span class="nn">com.xilinx.rapidwright.device</span> <span class="kn">import</span> <span class="n">BEL</span>
<span class="kn">from</span> <span class="nn">com.xilinx.rapidwright.device</span> <span class="kn">import</span> <span class="n">SitePIP</span>
<span class="kn">from</span> <span class="nn">com.xilinx.rapidwright.device</span> <span class="kn">import</span> <span class="n">SiteTypeEnum</span>
<span class="kn">from</span> <span class="nn">com.xilinx.rapidwright.edif</span> <span class="kn">import</span> <span class="n">EDIFCell</span>
<span class="kn">from</span> <span class="nn">com.xilinx.rapidwright.edif</span> <span class="kn">import</span> <span class="n">EDIFCellInst</span>
<span class="kn">from</span> <span class="nn">com.xilinx.rapidwright.edif</span> <span class="kn">import</span> <span class="n">EDIFDirection</span>
<span class="kn">from</span> <span class="nn">com.xilinx.rapidwright.edif</span> <span class="kn">import</span> <span class="n">EDIFNet</span>
<span class="kn">from</span> <span class="nn">com.xilinx.rapidwright.edif</span> <span class="kn">import</span> <span class="n">EDIFNetlist</span>
<span class="kn">from</span> <span class="nn">com.xilinx.rapidwright.edif</span> <span class="kn">import</span> <span class="n">EDIFPort</span>
<span class="kn">from</span> <span class="nn">com.xilinx.rapidwright.edif</span> <span class="kn">import</span> <span class="n">EDIFPortInst</span>
<span class="kn">from</span> <span class="nn">com.xilinx.rapidwright.edif</span> <span class="kn">import</span> <span class="n">EDIFTools</span>
<span class="kn">from</span> <span class="nn">com.xilinx.rapidwright.edif</span> <span class="kn">import</span> <span class="n">EDIFParser</span>
<span class="kn">from</span> <span class="nn">com.xilinx.rapidwright.edif</span> <span class="kn">import</span> <span class="n">EDIFLibrary</span>
<span class="kn">from</span> <span class="nn">com.xilinx.rapidwright.edif</span> <span class="kn">import</span> <span class="n">EDIFPropertyObject</span>
<span class="kn">from</span> <span class="nn">com.xilinx.rapidwright.edif</span> <span class="kn">import</span> <span class="n">EDIFValueType</span>
<span class="kn">from</span> <span class="nn">com.xilinx.rapidwright.router</span> <span class="kn">import</span> <span class="n">RouteNode</span>
<span class="kn">from</span> <span class="nn">com.xilinx.rapidwright.router</span> <span class="kn">import</span> <span class="n">Router</span>
<span class="kn">from</span> <span class="nn">com.xilinx.rapidwright.util</span> <span class="kn">import</span> <span class="n">FileTools</span>
<span class="kn">from</span> <span class="nn">com.xilinx.rapidwright.util</span> <span class="kn">import</span> <span class="n">MessageGenerator</span>
</code></pre></div></div>

<h2 id="step-0-user-configuration-data">Step 0: User Configuration Data</h2>
<p>Next, we manually specify some user configuration data that will guide the hardware generation process. This data includes:</p>

<ol>
  <li>Name of the <strong>EDIFCell</strong> that represents the full logical netlist. To simplify the code, we use the same name as the top module in our Verilog file i.e. <em>top</em>.</li>
  <li>The device we will be using. In our case, this is the Arty A7-35t board.</li>
  <li>Name of the synthesized JSON file output by Yosys.</li>
  <li>Location constraints and other parameters for external IO pins in our design.</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">topModule</span> <span class="o">=</span> <span class="s">"top"</span>
<span class="n">device</span> <span class="o">=</span> <span class="s">"xc7a35tcsg324-1"</span>
<span class="n">filename</span> <span class="o">=</span> <span class="s">"top.json"</span>

<span class="n">constraints</span> <span class="o">=</span> <span class="p">{</span>
               <span class="s">'i_clk'</span> <span class="p">:</span> <span class="p">{</span><span class="s">'LOC'</span> <span class="p">:</span> <span class="s">'E3'</span><span class="p">,</span> <span class="s">'IOSTANDARD'</span> <span class="p">:</span> <span class="s">'LVCMOS33'</span> <span class="p">,</span> <span class="s">'SLEW'</span> <span class="p">:</span> <span class="s">'FAST'</span><span class="p">,</span> <span class="s">'IN_TERM'</span> <span class="p">:</span> <span class="s">'NONE'</span> <span class="p">,</span> <span class="s">'PULL_TYPE'</span> <span class="p">:</span> <span class="s">'NONE'</span><span class="p">},</span>
               <span class="s">'in0[1]'</span> <span class="p">:</span> <span class="p">{</span><span class="s">'LOC'</span> <span class="p">:</span> <span class="s">'C11'</span><span class="p">,</span> <span class="s">'IOSTANDARD'</span> <span class="p">:</span> <span class="s">'LVCMOS33'</span> <span class="p">,</span> <span class="s">'SLEW'</span> <span class="p">:</span> <span class="s">'FAST'</span><span class="p">,</span> <span class="s">'IN_TERM'</span> <span class="p">:</span> <span class="s">'NONE'</span> <span class="p">,</span> <span class="s">'PULL_TYPE'</span> <span class="p">:</span> <span class="s">'NONE'</span><span class="p">},</span>
               <span class="s">'in0[0]'</span> <span class="p">:</span> <span class="p">{</span><span class="s">'LOC'</span> <span class="p">:</span> <span class="s">'A8'</span><span class="p">,</span> <span class="s">'IOSTANDARD'</span> <span class="p">:</span> <span class="s">'LVCMOS33'</span> <span class="p">,</span> <span class="s">'SLEW'</span> <span class="p">:</span> <span class="s">'FAST'</span><span class="p">,</span> <span class="s">'IN_TERM'</span> <span class="p">:</span> <span class="s">'NONE'</span> <span class="p">,</span> <span class="s">'PULL_TYPE'</span> <span class="p">:</span> <span class="s">'NONE'</span><span class="p">},</span>
               <span class="s">'in1[1]'</span> <span class="p">:</span> <span class="p">{</span><span class="s">'LOC'</span> <span class="p">:</span> <span class="s">'A10'</span><span class="p">,</span> <span class="s">'IOSTANDARD'</span> <span class="p">:</span> <span class="s">'LVCMOS33'</span> <span class="p">,</span> <span class="s">'SLEW'</span> <span class="p">:</span> <span class="s">'FAST'</span><span class="p">,</span> <span class="s">'IN_TERM'</span> <span class="p">:</span> <span class="s">'NONE'</span> <span class="p">,</span> <span class="s">'PULL_TYPE'</span> <span class="p">:</span> <span class="s">'NONE'</span><span class="p">},</span>
               <span class="s">'in1[0]'</span> <span class="p">:</span> <span class="p">{</span><span class="s">'LOC'</span> <span class="p">:</span> <span class="s">'C10'</span><span class="p">,</span> <span class="s">'IOSTANDARD'</span> <span class="p">:</span> <span class="s">'LVCMOS33'</span> <span class="p">,</span> <span class="s">'SLEW'</span> <span class="p">:</span> <span class="s">'FAST'</span><span class="p">,</span> <span class="s">'IN_TERM'</span> <span class="p">:</span> <span class="s">'NONE'</span> <span class="p">,</span> <span class="s">'PULL_TYPE'</span> <span class="p">:</span> <span class="s">'NONE'</span><span class="p">},</span>
               <span class="s">'out[3]'</span> <span class="p">:</span> <span class="p">{</span><span class="s">'LOC'</span> <span class="p">:</span> <span class="s">'K1'</span><span class="p">,</span> <span class="s">'IOSTANDARD'</span> <span class="p">:</span> <span class="s">'LVCMOS33'</span> <span class="p">,</span> <span class="s">'SLEW'</span> <span class="p">:</span> <span class="s">'FAST'</span><span class="p">,</span> <span class="s">'IN_TERM'</span> <span class="p">:</span> <span class="s">'NONE'</span> <span class="p">,</span> <span class="s">'PULL_TYPE'</span> <span class="p">:</span> <span class="s">'NONE'</span><span class="p">},</span>
               <span class="s">'out[2]'</span> <span class="p">:</span> <span class="p">{</span><span class="s">'LOC'</span> <span class="p">:</span> <span class="s">'J3'</span><span class="p">,</span> <span class="s">'IOSTANDARD'</span> <span class="p">:</span> <span class="s">'LVCMOS33'</span> <span class="p">,</span> <span class="s">'SLEW'</span> <span class="p">:</span> <span class="s">'FAST'</span><span class="p">,</span> <span class="s">'IN_TERM'</span> <span class="p">:</span> <span class="s">'NONE'</span> <span class="p">,</span> <span class="s">'PULL_TYPE'</span> <span class="p">:</span> <span class="s">'NONE'</span><span class="p">},</span>
               <span class="s">'out[1]'</span> <span class="p">:</span> <span class="p">{</span><span class="s">'LOC'</span> <span class="p">:</span> <span class="s">'G3'</span><span class="p">,</span> <span class="s">'IOSTANDARD'</span> <span class="p">:</span> <span class="s">'LVCMOS33'</span> <span class="p">,</span> <span class="s">'SLEW'</span> <span class="p">:</span> <span class="s">'FAST'</span><span class="p">,</span> <span class="s">'IN_TERM'</span> <span class="p">:</span> <span class="s">'NONE'</span> <span class="p">,</span> <span class="s">'PULL_TYPE'</span> <span class="p">:</span> <span class="s">'NONE'</span><span class="p">},</span>
               <span class="s">'out[0]'</span> <span class="p">:</span> <span class="p">{</span><span class="s">'LOC'</span> <span class="p">:</span> <span class="s">'G6'</span><span class="p">,</span> <span class="s">'IOSTANDARD'</span> <span class="p">:</span> <span class="s">'LVCMOS33'</span> <span class="p">,</span> <span class="s">'SLEW'</span> <span class="p">:</span> <span class="s">'FAST'</span><span class="p">,</span> <span class="s">'IN_TERM'</span> <span class="p">:</span> <span class="s">'NONE'</span> <span class="p">,</span> <span class="s">'PULL_TYPE'</span> <span class="p">:</span> <span class="s">'NONE'</span><span class="p">}</span>
             <span class="p">}</span>
</code></pre></div></div>
<h2 id="step-1-importing-a-post-synthesis-json-file">Step 1: Importing A Post-Synthesis JSON File</h2>
<p>The next step is to import the JSON file generated by Yosys and create a logic netlist. Since RapidWright does not have native support for JSON, we have to write our own routines for populating the <strong>EDIF</strong> objects. While it is not necessary to create the logical netlist (and instead go straight to building a physical netlist from the JSON file), doing so makes it easier (and faster) to write, visualize and debug code/circuits.</p>

<h3 id="read-yosys-json-file">Read Yosys JSON File</h3>
<p>The first routine reads in a user specified JSON file into a local dictionary called <code class="highlighter-rouge">jnet</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">json</span>
<span class="k">def</span> <span class="nf">read_file</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">'r'</span><span class="p">)</span> <span class="k">as</span> <span class="nb">file</span><span class="p">:</span>
        <span class="n">jnet</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">file</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">jnet</span>
</code></pre></div></div>

<h3 id="build-hdi_primitives-technology-library">Build “hdi_primitives” Technology Library</h3>
<p>At the highest level of its hierarchy, the Yosys JSON file is composed of “modules”. Each module represents a unique technology specific building block that can be used to construct a logical netlist (our design is also a module). All possible modules supported by the target are provided, even if they are not being used in the actual design. We will use these modules to build our <strong>EDIFLibrary</strong>. The code for this, as well as its breakdown, is given below. Note that not all information provided for each module in the JSON file will be needed.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">buildLibrary</span><span class="p">(</span><span class="n">jnet</span><span class="p">,</span> <span class="n">library</span><span class="p">):</span>
    <span class="n">topModule</span> <span class="o">=</span> <span class="n">library</span><span class="o">.</span><span class="n">getNetlist</span><span class="p">()</span><span class="o">.</span><span class="n">getTopCell</span><span class="p">()</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">jnet</span><span class="p">[</span><span class="s">'modules'</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">cell</span> <span class="o">==</span> <span class="n">topModule</span><span class="p">:</span> <span class="k">continue</span>
        <span class="k">if</span> <span class="n">library</span><span class="o">.</span><span class="n">containsCell</span><span class="p">(</span><span class="n">cell</span><span class="p">):</span> <span class="k">continue</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">EDIFCell</span><span class="p">(</span><span class="n">library</span><span class="p">,</span><span class="n">cell</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">port</span> <span class="ow">in</span> <span class="n">jnet</span><span class="p">[</span><span class="s">'modules'</span><span class="p">][</span><span class="n">cell</span><span class="p">][</span><span class="s">'ports'</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">jnet</span><span class="p">[</span><span class="s">'modules'</span><span class="p">][</span><span class="n">cell</span><span class="p">][</span><span class="s">'ports'</span><span class="p">][</span><span class="n">port</span><span class="p">][</span><span class="s">'direction'</span><span class="p">]</span> <span class="o">==</span> <span class="s">"input"</span><span class="p">:</span>
                <span class="n">direction</span> <span class="o">=</span> <span class="n">EDIFDirection</span><span class="o">.</span><span class="n">INPUT</span>
            <span class="k">elif</span> <span class="n">jnet</span><span class="p">[</span><span class="s">'modules'</span><span class="p">][</span><span class="n">cell</span><span class="p">][</span><span class="s">'ports'</span><span class="p">][</span><span class="n">port</span><span class="p">][</span><span class="s">'direction'</span><span class="p">]</span> <span class="o">==</span> <span class="s">"output"</span><span class="p">:</span>
                <span class="n">direction</span> <span class="o">=</span> <span class="n">EDIFDirection</span><span class="o">.</span><span class="n">OUTPUT</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">direction</span> <span class="o">=</span> <span class="n">EDIFDirection</span><span class="o">.</span><span class="n">INOUT</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">createPort</span><span class="p">(</span><span class="n">port</span><span class="p">,</span><span class="n">direction</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">library</span><span class="o">.</span><span class="n">addCell</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
</code></pre></div></div>

<p>Our routine takes the imported JSON file <code class="highlighter-rouge">jnet</code> and the <strong>EDIFLibrary</strong> <code class="highlighter-rouge">library</code> as inputs. It modifies <code class="highlighter-rouge">library</code> directly instead of returning a new <strong>EDIFLibrary</strong>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">buildLibrary</span><span class="p">(</span><span class="n">jnet</span><span class="p">,</span> <span class="n">library</span><span class="p">):</span>
</code></pre></div></div>

<p>We begin by getting the name of the top module in our Verilog code, which we set as the name of the <strong>EDIFCell</strong> that represents our overall design. Note that, as discussed earlier, this will be the only <strong>EDIFCell</strong> in our <strong>EDIFNetlist</strong>, and is automatically created when we create our <strong>Design</strong>. Also note that, complimentary to <strong>EDIFNetlist</strong>, the <strong>EDIFLibrary</strong> will have an <strong>EDIFCell</strong> for all modules except our design - and we will convert an <strong>EDIFCell</strong> in the <strong>EDIFLibrary</strong> to an <strong>EDIFCellInst</strong> when instantiating it.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">topModule</span> <span class="o">=</span> <span class="n">library</span><span class="o">.</span><span class="n">getNetlist</span><span class="p">()</span><span class="o">.</span><span class="n">getTopCell</span><span class="p">()</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span>
</code></pre></div></div>

<p>Next, we loop over all modules in <code class="highlighter-rouge">jnet</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">jnet</span><span class="p">[</span><span class="s">'modules'</span><span class="p">]:</span>
</code></pre></div></div>

<p>If a module is our custom design or has already been added to <strong>EDIFLibrary</strong>, we will skip it.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">if</span> <span class="n">cell</span> <span class="o">==</span> <span class="n">topModule</span><span class="p">:</span> <span class="k">continue</span>
        <span class="k">if</span> <span class="n">library</span><span class="o">.</span><span class="n">containsCell</span><span class="p">(</span><span class="n">cell</span><span class="p">):</span> <span class="k">continue</span>
</code></pre></div></div>

<p>Next we create an <strong>EDIFCell</strong> for that module.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>       <span class="n">ret</span> <span class="o">=</span> <span class="n">EDIFCell</span><span class="p">(</span><span class="n">library</span><span class="p">,</span><span class="n">cell</span><span class="p">)</span>
</code></pre></div></div>
<p>Next we will create an <strong>EDIFPort</strong> for each port of the module. Doing so requires calling the <code class="highlighter-rouge">createPort()</code> routine, which has three inputs: i) name of the port, ii)  an <strong>EDIFDirection</strong>, and iii) the bus width (almost always 1 for target technology modules). All the required information is available in <code class="highlighter-rouge">jnet</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>       <span class="k">for</span> <span class="n">port</span> <span class="ow">in</span> <span class="n">jnet</span><span class="p">[</span><span class="s">'modules'</span><span class="p">][</span><span class="n">cell</span><span class="p">][</span><span class="s">'ports'</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">jnet</span><span class="p">[</span><span class="s">'modules'</span><span class="p">][</span><span class="n">cell</span><span class="p">][</span><span class="s">'ports'</span><span class="p">][</span><span class="n">port</span><span class="p">][</span><span class="s">'direction'</span><span class="p">]</span> <span class="o">==</span> <span class="s">"input"</span><span class="p">:</span>
                <span class="n">direction</span> <span class="o">=</span> <span class="n">EDIFDirection</span><span class="o">.</span><span class="n">INPUT</span>
            <span class="k">elif</span> <span class="n">jnet</span><span class="p">[</span><span class="s">'modules'</span><span class="p">][</span><span class="n">cell</span><span class="p">][</span><span class="s">'ports'</span><span class="p">][</span><span class="n">port</span><span class="p">][</span><span class="s">'direction'</span><span class="p">]</span> <span class="o">==</span> <span class="s">"output"</span><span class="p">:</span>
                <span class="n">direction</span> <span class="o">=</span> <span class="n">EDIFDirection</span><span class="o">.</span><span class="n">OUTPUT</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">direction</span> <span class="o">=</span> <span class="n">EDIFDirection</span><span class="o">.</span><span class="n">INOUT</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">createPort</span><span class="p">(</span><span class="n">port</span><span class="p">,</span><span class="n">direction</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p>Finally, we add the <strong>EDIFCell</strong> to the <code class="highlighter-rouge">library</code>. Note that this may not be necessary if the <strong>EDIFCell</strong> constructor automatically adds the <strong>EDIFCell</strong> to the <strong>EDIFLibrary</strong>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="n">library</span><span class="o">.</span><span class="n">addCell</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
</code></pre></div></div>

<p>Once we have built our <strong>EDIFLibrary</strong>, we can now start building <strong>EDIFCell</strong>s for our <strong>EDIFNetlist</strong>. As mentioned previously, there will be only one <strong>EDIFCell</strong> in our <strong>EDIFNetlist</strong> which represents our design i.e. the module that we skipped when building our <strong>EDIFLibrary</strong>. This <strong>EDIFCell</strong> is automatically created along with <strong>Design</strong> , and can be accessed by calling the routine <code class="highlighter-rouge">getTopCell()</code> from <strong>EDIFNetlist</strong> (which in turn is accessed by calling the <code class="highlighter-rouge">getNetlist()</code> routine in <strong>Design</strong>).</p>

<h3 id="define-external-io-ports">Define External IO Ports</h3>
<p>The first step to building the <strong>EDIFCell</strong> in <strong>EDIFNetlist</strong> is creating <strong>EDIFPort</strong>s for it, which will also be the external I/O ports. The code for this, as well as its breakdown, is given below.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">defineExternalPorts</span><span class="p">(</span><span class="n">jnet</span><span class="p">,</span> <span class="n">topCell</span><span class="p">):</span>
    <span class="n">topModule</span> <span class="o">=</span> <span class="n">topCell</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">port</span> <span class="ow">in</span> <span class="n">jnet</span><span class="p">[</span><span class="s">'modules'</span><span class="p">][</span><span class="n">topModule</span><span class="p">][</span><span class="s">"ports"</span><span class="p">]:</span>
        <span class="n">port_data</span> <span class="o">=</span> <span class="n">jnet</span><span class="p">[</span><span class="s">'modules'</span><span class="p">][</span><span class="n">topModule</span><span class="p">][</span><span class="s">"ports"</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">port</span><span class="p">)</span>
        <span class="n">port_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">port</span><span class="p">)</span>
        <span class="n">num_pins</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">port_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">"bits"</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_pins</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">port_name</span> <span class="o">+</span> <span class="p">(</span><span class="s">""</span> <span class="k">if</span> <span class="n">num_pins</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">(</span><span class="s">"["</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>  <span class="o">+</span> <span class="s">"]"</span><span class="p">))</span>
            <span class="n">connectionID</span> <span class="o">=</span> <span class="n">port_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">"bits"</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">direction</span> <span class="o">=</span> <span class="n">port_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">"direction"</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s">"input"</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">topCell</span><span class="o">.</span><span class="n">createPort</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">EDIFDirection</span><span class="o">.</span><span class="n">INPUT</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s">"output"</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">topCell</span><span class="o">.</span><span class="n">createPort</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">EDIFDirection</span><span class="o">.</span><span class="n">OUTPUT</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">topCell</span><span class="o">.</span><span class="n">createPort</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">EDIFDirection</span><span class="o">.</span><span class="n">INOUT</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p>Our routine takes the imported JSON file <code class="highlighter-rouge">jnet</code> and the <strong>EDIFCell</strong> <code class="highlighter-rouge">topCell</code>  as input, and adds <strong>EDIFPort</strong>s to <code class="highlighter-rouge">topCell</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">defineExternalPorts</span><span class="p">(</span><span class="n">jnet</span><span class="p">,</span> <span class="n">topCell</span><span class="p">):</span>
</code></pre></div></div>

<p>We begin by getting the name of the top module in our Verilog code i.e. the name of the <strong>EDIFCell</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">topModule</span> <span class="o">=</span> <span class="n">topCell</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span>
</code></pre></div></div>
<p>Using this name, we loop over all ports for the module and access each port’s name (<code class="highlighter-rouge">port_name</code>) and parameters (<code class="highlighter-rouge">port_data</code>).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">for</span> <span class="n">port</span> <span class="ow">in</span> <span class="n">jnet</span><span class="p">[</span><span class="s">'modules'</span><span class="p">][</span><span class="n">topModule</span><span class="p">][</span><span class="s">"ports"</span><span class="p">]:</span>
        <span class="n">port_data</span> <span class="o">=</span> <span class="n">jnet</span><span class="p">[</span><span class="s">'modules'</span><span class="p">][</span><span class="n">topModule</span><span class="p">][</span><span class="s">"ports"</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">port</span><span class="p">)</span>
        <span class="n">port_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">port</span><span class="p">)</span>
</code></pre></div></div>

<p>Since we are working with a custom module, instead of FPGA technology primitives (in <strong>EDIFLibrary</strong>), ports are not necessarily of size 1 and can instead be buses as well. To ensure consistency amount how we deal with all <strong>EDIFCell</strong> s, we will (where applicable) loop over each pin in the bus, append a suffix to the name, and create an <strong>EDIFPort</strong> (of size 1) for it.  For example, in our design, the “out” signal is a bus of width 4, but we will create four separate <strong>EDIFPort</strong>s for it named <em>out[0]</em>, <em>out[1]</em>, <em>out[2]</em> and <em>out[3]</em>. In the code fragment below, we find the number of pins from <code class="highlighter-rouge">port_data</code> and assign a suffix to the <code class="highlighter-rouge">port_name</code> string.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="n">num_pins</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">port_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">"bits"</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_pins</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">port_name</span> <span class="o">+</span> <span class="p">(</span><span class="s">""</span> <span class="k">if</span> <span class="n">num_pins</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">(</span><span class="s">"["</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>  <span class="o">+</span> <span class="s">"]"</span><span class="p">))</span>
</code></pre></div></div>
<p>Next, we determine the <strong>EDIFDirection</strong> value and create the <strong>EDIFPort</strong> for this pin.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="n">direction</span> <span class="o">=</span> <span class="n">port_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">"direction"</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s">"input"</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">topCell</span><span class="o">.</span><span class="n">createPort</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">EDIFDirection</span><span class="o">.</span><span class="n">INPUT</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s">"output"</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">topCell</span><span class="o">.</span><span class="n">createPort</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">EDIFDirection</span><span class="o">.</span><span class="n">OUTPUT</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">topCell</span><span class="o">.</span><span class="n">createPort</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">EDIFDirection</span><span class="o">.</span><span class="n">INOUT</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="create-logical-cellinst-objects">Create Logical CellInst Objects</h3>
<p>Now that we have set the external I/O ports for our logical netlist (being built within the <strong>EDIFCell</strong> <code class="highlighter-rouge">topCell</code>), we will now add in components of the netlist from the <strong>EDIFLibrary</strong> i.e. LUTs, FDRE, Buffers etc. The code for this, as well as its breakdown, is given below.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">createEDIFCellInsts</span><span class="p">(</span><span class="n">jnet</span><span class="p">,</span> <span class="n">topCell</span><span class="p">,</span> <span class="n">library</span><span class="p">):</span>
    <span class="n">topModule</span> <span class="o">=</span> <span class="n">topCell</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">jnet</span><span class="p">[</span><span class="s">'modules'</span><span class="p">][</span><span class="n">topModule</span><span class="p">][</span><span class="s">"cells"</span><span class="p">]:</span>
        <span class="n">cell_data</span> <span class="o">=</span> <span class="n">jnet</span><span class="p">[</span><span class="s">'modules'</span><span class="p">][</span><span class="s">'top'</span><span class="p">][</span><span class="s">'cells'</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
        <span class="n">cell_name</span> <span class="o">=</span> <span class="n">cell</span>
        <span class="n">cell_type</span> <span class="o">=</span> <span class="n">cell_data</span><span class="p">[</span><span class="s">'type'</span><span class="p">]</span>
        <span class="n">cell_properties</span> <span class="o">=</span> <span class="n">cell_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">'parameters'</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">EDIFCellInst</span><span class="p">(</span><span class="n">cell_name</span><span class="p">,</span> <span class="n">library</span><span class="o">.</span><span class="n">getCell</span><span class="p">(</span><span class="n">cell_type</span><span class="p">),</span><span class="n">topCell</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">proprty</span> <span class="ow">in</span> <span class="n">cell_properties</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">cell_properties</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">proprty</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="s">'x'</span><span class="p">:</span> <span class="k">continue</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">addProperty</span><span class="p">(</span><span class="n">proprty</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="mi">2</span><span class="p">)),</span> <span class="n">EDIFValueType</span><span class="o">.</span><span class="n">INTEGER</span> <span class="p">)</span>
</code></pre></div></div>

<p>The inputs to our routine are the imported JSON file <code class="highlighter-rouge">jnet</code>,  the <strong>EDIFCell</strong> <code class="highlighter-rouge">topCell</code> that we are building, and the <strong>EDIFLibrary</strong> that we built earlier. Based on the composition of our logical netlist, as specified in <code class="highlighter-rouge">jnet</code>, we will take <strong>EDIFCell</strong>s from <code class="highlighter-rouge">library</code>,  create <strong>EDIFCellInst</strong>s for them in<code class="highlighter-rouge">topCell</code>, and copy over component properties e.g. LUT values.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">createEDIFCellInsts</span><span class="p">(</span><span class="n">jnet</span><span class="p">,</span> <span class="n">topCell</span><span class="p">,</span> <span class="n">library</span><span class="p">):</span>
</code></pre></div></div>

<p>We begin by getting the name of the top module in our Verilog code.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">topModule</span> <span class="o">=</span> <span class="n">topCell</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span>
</code></pre></div></div>

<p>Using <code class="highlighter-rouge">topModule</code>, we loop over all its “cells” in <code class="highlighter-rouge">jnet</code> and get the name, type and properties of each cell. In this context, a cell is an instantiation of one of the modules we used to build <code class="highlighter-rouge">library</code>. Note that a cell’s <code class="highlighter-rouge">type</code> here is also referred to as its <em>Unisim</em> in RapidWright, and the <strong>Unisim</strong> class enumerates the different <em>Unisim</em> primitives supported by Xilinx devices.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">jnet</span><span class="p">[</span><span class="s">'modules'</span><span class="p">][</span><span class="n">topModule</span><span class="p">][</span><span class="s">"cells"</span><span class="p">]:</span>
        <span class="n">cell_data</span> <span class="o">=</span> <span class="n">jnet</span><span class="p">[</span><span class="s">'modules'</span><span class="p">][</span><span class="s">'top'</span><span class="p">][</span><span class="s">'cells'</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
        <span class="n">cell_name</span> <span class="o">=</span> <span class="n">cell</span>
        <span class="n">cell_type</span> <span class="o">=</span> <span class="n">cell_data</span><span class="p">[</span><span class="s">'type'</span><span class="p">]</span>
        <span class="n">cell_properties</span> <span class="o">=</span> <span class="n">cell_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">'parameters'</span><span class="p">)</span>
</code></pre></div></div>

<p>Continuing the loop, we create a <strong>EDIFCellInst</strong> for each cell by getting the corresponding <strong>EDIFCell</strong> from <code class="highlighter-rouge">library</code>.  This <strong>EDIFCellInst</strong> is added to <code class="highlighter-rouge">topCell</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="n">ret</span> <span class="o">=</span> <span class="n">EDIFCellInst</span><span class="p">(</span><span class="n">cell_name</span><span class="p">,</span> <span class="n">library</span><span class="o">.</span><span class="n">getCell</span><span class="p">(</span><span class="n">cell_type</span><span class="p">),</span><span class="n">topCell</span><span class="p">)</span>
</code></pre></div></div>

<p>Finally, for each property of each <strong>EDIFCellInst</strong> that we create, we will add properties. While this is not a strict requirement, we express property values as integers; from what we have observed thus far, the default choice for Yosys is binary.  If a property is undefined or is not applicable, it is denoted by “x” in <code class="highlighter-rouge">jnet</code> and will be skipped.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">for</span> <span class="n">proprty</span> <span class="ow">in</span> <span class="n">cell_properties</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">cell_properties</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">proprty</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="s">'x'</span><span class="p">:</span> <span class="k">continue</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">addProperty</span><span class="p">(</span><span class="n">proprty</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="mi">2</span><span class="p">)),</span> <span class="n">EDIFValueType</span><span class="o">.</span><span class="n">INTEGER</span> <span class="p">)</span>
</code></pre></div></div>

<h3 id="create-logical-nets">Create Logical Nets</h3>
<p>At this point, we have a logic netlist with components and external I/O.  The only thing left at this point is to build the nets/wires that connect everything together i.e. the <strong>EDIFNet</strong>s. We will do this in three passes. In the first pass we will create signal <strong>EDIFNet</strong>s. In the second pass, we will remove any empty <strong>EDIFNet</strong>s (caused by redundancy in the Yosys output). Finally, the third pass will add in the power <strong>EDIFNet</strong>s i.e. VCC and GND (used to supply hard 1 or 0 logic inputs respectively).</p>

<p>Let’s begin with our first pass: creating  and building <strong>EDIFNet</strong>s for signals. The code for this, as well as its breakdown, is given below.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">createEDIFPorts</span><span class="p">(</span><span class="n">jnet</span><span class="p">,</span> <span class="n">topCell</span><span class="p">):</span>
    <span class="n">topModule</span> <span class="o">=</span> <span class="n">topCell</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span>
    <span class="n">ports</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">net</span> <span class="ow">in</span> <span class="n">jnet</span><span class="p">[</span><span class="s">'modules'</span><span class="p">][</span><span class="n">topModule</span><span class="p">][</span><span class="s">"netnames"</span><span class="p">]:</span>
        <span class="n">connectionIDs</span> <span class="o">=</span> <span class="n">jnet</span><span class="p">[</span><span class="s">'modules'</span><span class="p">][</span><span class="n">topModule</span><span class="p">][</span><span class="s">"netnames"</span><span class="p">][</span><span class="n">net</span><span class="p">][</span><span class="s">'bits'</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">connectionIDs</span><span class="p">)):</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">topCell</span><span class="o">.</span><span class="n">createNet</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">net</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="s">""</span> <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">connectionIDs</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">(</span><span class="s">"["</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>  <span class="o">+</span> <span class="s">"]"</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">jnet</span><span class="p">[</span><span class="s">'modules'</span><span class="p">][</span><span class="n">topModule</span><span class="p">][</span><span class="s">"cells"</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">port</span> <span class="ow">in</span> <span class="n">jnet</span><span class="p">[</span><span class="s">'modules'</span><span class="p">][</span><span class="n">topModule</span><span class="p">][</span><span class="s">"cells"</span><span class="p">][</span><span class="n">cell</span><span class="p">][</span><span class="s">'connections'</span><span class="p">]:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">jnet</span><span class="p">[</span><span class="s">'modules'</span><span class="p">][</span><span class="n">topModule</span><span class="p">][</span><span class="s">"cells"</span><span class="p">][</span><span class="n">cell</span><span class="p">][</span><span class="s">'connections'</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">port</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">connectionIDs</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="p">((</span><span class="n">port</span><span class="p">,</span><span class="n">cell</span><span class="p">)</span> <span class="ow">in</span> <span class="n">ports</span><span class="p">):</span> <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">ret</span><span class="o">.</span><span class="n">createPortInst</span><span class="p">(</span><span class="n">port</span><span class="p">,</span><span class="n">topCell</span><span class="o">.</span><span class="n">getCellInst</span><span class="p">(</span><span class="n">cell</span><span class="p">))</span>
                            <span class="n">ports</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">port</span><span class="p">,</span><span class="n">cell</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">port</span> <span class="ow">in</span> <span class="n">jnet</span><span class="p">[</span><span class="s">'modules'</span><span class="p">][</span><span class="n">topModule</span><span class="p">][</span><span class="s">'ports'</span><span class="p">]:</span>
                <span class="n">topConnectionIDs</span> <span class="o">=</span> <span class="n">jnet</span><span class="p">[</span><span class="s">'modules'</span><span class="p">][</span><span class="n">topModule</span><span class="p">][</span><span class="s">'ports'</span><span class="p">][</span><span class="n">port</span><span class="p">][</span><span class="s">'bits'</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">topConnectionIDs</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">topConnectionIDs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">connectionIDs</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">port</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="s">""</span> <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">topConnectionIDs</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">(</span><span class="s">"["</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>  <span class="o">+</span> <span class="s">"]"</span><span class="p">))</span>
                        <span class="k">if</span> <span class="p">((</span><span class="n">name</span><span class="p">,</span><span class="n">topModule</span><span class="p">)</span> <span class="ow">in</span> <span class="n">ports</span><span class="p">):</span> <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">ret</span><span class="o">.</span><span class="n">createPortInst</span><span class="p">(</span><span class="n">topCell</span><span class="o">.</span><span class="n">getPort</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
                            <span class="n">ports</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">name</span><span class="p">,</span><span class="n">topModule</span><span class="p">))</span>
</code></pre></div></div>

<p>The inputs to our routine are the imported JSON file <code class="highlighter-rouge">jnet</code> and the <strong>EDIFCell</strong> <code class="highlighter-rouge">topCell</code> that we are building. Based on the data in <code class="highlighter-rouge">jnet</code>, we will: i) create and add each  <strong>EDIFNet</strong> to <code class="highlighter-rouge">topCell</code> and , ii) create and add <strong>EDIFPortInst</strong>s to each <strong>EDIFNet</strong> (where applicable).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">createEDIFPorts</span><span class="p">(</span><span class="n">jnet</span><span class="p">,</span> <span class="n">topCell</span><span class="p">):</span>
</code></pre></div></div>
<p>We begin by getting the name of the top module in our Verilog code.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">topModule</span> <span class="o">=</span> <span class="n">topCell</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span>
</code></pre></div></div>

<p>Next we initialize an empty list called <code class="highlighter-rouge">ports</code>. Every time an <strong>EDIFPortInst</strong> is created, we will add it to <code class="highlighter-rouge">ports</code> so that we can keep track and avoid re-creating it for a different <strong>EDIFNet</strong>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">ports</span> <span class="o">=</span> <span class="p">[]</span>
</code></pre></div></div>

<p>Yosys stores most of net data under “netnames” in each module. We will loop over all the fields in “netnames” in order to create <strong>EDIFNet</strong>s.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">for</span> <span class="n">net</span> <span class="ow">in</span> <span class="n">jnet</span><span class="p">[</span><span class="s">'modules'</span><span class="p">][</span><span class="n">topModule</span><span class="p">][</span><span class="s">"netnames"</span><span class="p">]:</span>
</code></pre></div></div>

<p>Next, we create an <strong>EDIFNet</strong> for each net using the net name given in <code class="highlighter-rouge">jnet</code>. While all nets have unique IDs, stored in the “bits” field of the net in <code class="highlighter-rouge">jnet</code>, Yosys will sometimes group a number of nets under one name. In such cases, we will use the unique ID to create a unique name for it. Note that we do not append the unique ID to the group name; rather, we run a counter based on the length of the “bits” field (<code class="highlighter-rouge">connectionIDs</code>) and use its value.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="n">connectionIDs</span> <span class="o">=</span> <span class="n">jnet</span><span class="p">[</span><span class="s">'modules'</span><span class="p">][</span><span class="n">topModule</span><span class="p">][</span><span class="s">"netnames"</span><span class="p">][</span><span class="n">net</span><span class="p">][</span><span class="s">'bits'</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">connectionIDs</span><span class="p">)):</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">topCell</span><span class="o">.</span><span class="n">createNet</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">net</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="s">""</span> <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">connectionIDs</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">(</span><span class="s">"["</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>  <span class="o">+</span> <span class="s">"]"</span><span class="p">)))</span>
</code></pre></div></div>

<p>For each <strong>EDIFNet</strong> that we create, we loop over every port of every cell for <code class="highlighter-rouge">topModule</code> in <code class="highlighter-rouge">jnet</code>, and get the unique net IDs that the port is connected to. These IDs are stored in <code class="highlighter-rouge">value</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">jnet</span><span class="p">[</span><span class="s">'modules'</span><span class="p">][</span><span class="n">topModule</span><span class="p">][</span><span class="s">"cells"</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">port</span> <span class="ow">in</span> <span class="n">jnet</span><span class="p">[</span><span class="s">'modules'</span><span class="p">][</span><span class="n">topModule</span><span class="p">][</span><span class="s">"cells"</span><span class="p">][</span><span class="n">cell</span><span class="p">][</span><span class="s">'connections'</span><span class="p">]:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">jnet</span><span class="p">[</span><span class="s">'modules'</span><span class="p">][</span><span class="n">topModule</span><span class="p">][</span><span class="s">"cells"</span><span class="p">][</span><span class="n">cell</span><span class="p">][</span><span class="s">'connections'</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">port</span><span class="p">)</span>
</code></pre></div></div>

<p>Next, we compare the net ID from cell connection data to the net ID of the current <strong>EDIFNet</strong>.  If there is a match, and we have not already added this unique “port,cell” tuple to <code class="highlighter-rouge">ports</code>, we’ll create an <strong>EDIFPortInst</strong> for it in the current <strong>EDIFNet</strong> and add the corresponding tuple to <code class="highlighter-rouge">ports</code>.  Otherwise, we skip this port.</p>

<p>In some cases, a port may be connected to multiple nets. By default, we select the first net it <code class="highlighter-rouge">value</code>. We might need an extra step here where we merge nets in <code class="highlighter-rouge">jnet</code> to ensure a port is only connected to a single net. Since it wasn’t needed for the current design, it was skipped for now.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                    <span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">connectionIDs</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="p">((</span><span class="n">port</span><span class="p">,</span><span class="n">cell</span><span class="p">)</span> <span class="ow">in</span> <span class="n">ports</span><span class="p">):</span> <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">ret</span><span class="o">.</span><span class="n">createPortInst</span><span class="p">(</span><span class="n">port</span><span class="p">,</span><span class="n">topCell</span><span class="o">.</span><span class="n">getCellInst</span><span class="p">(</span><span class="n">cell</span><span class="p">))</span>
                            <span class="n">ports</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">port</span><span class="p">,</span><span class="n">cell</span><span class="p">))</span>
</code></pre></div></div>

<p>So far, for the <strong>EDIFNet</strong> that we  are currently building,  we only created <strong>EDIFPortInst</strong>s for <strong>EDIFCellInst</strong>s in <code class="highlighter-rouge">topCell</code> (since we looped over “cells”). The <strong>EDIFNet</strong> may also connect to external I/O ports i.e. ports of <code class="highlighter-rouge">topModule</code>. To check for this and create <strong>EDIFPortInst</strong>s where applicable for external I/O ports, we repeat the above process by looping over ports in <code class="highlighter-rouge">topModule</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="k">for</span> <span class="n">port</span> <span class="ow">in</span> <span class="n">jnet</span><span class="p">[</span><span class="s">'modules'</span><span class="p">][</span><span class="n">topModule</span><span class="p">][</span><span class="s">'ports'</span><span class="p">]:</span>
                <span class="n">topConnectionIDs</span> <span class="o">=</span> <span class="n">jnet</span><span class="p">[</span><span class="s">'modules'</span><span class="p">][</span><span class="n">topModule</span><span class="p">][</span><span class="s">'ports'</span><span class="p">][</span><span class="n">port</span><span class="p">][</span><span class="s">'bits'</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">topConnectionIDs</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">topConnectionIDs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">connectionIDs</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">port</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="s">""</span> <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">topConnectionIDs</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">(</span><span class="s">"["</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>  <span class="o">+</span> <span class="s">"]"</span><span class="p">))</span>
                        <span class="k">if</span> <span class="p">((</span><span class="n">name</span><span class="p">,</span><span class="n">topModule</span><span class="p">)</span> <span class="ow">in</span> <span class="n">ports</span><span class="p">):</span> <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">ret</span><span class="o">.</span><span class="n">createPortInst</span><span class="p">(</span><span class="n">topCell</span><span class="o">.</span><span class="n">getPort</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
                            <span class="n">ports</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">name</span><span class="p">,</span><span class="n">topModule</span><span class="p">))</span>
</code></pre></div></div>

<h3 id="clean-empty-nets">Clean Empty Nets</h3>

<p>In  the second pass, we remove any <strong>EDIFNet</strong> in <code class="highlighter-rouge">topCell</code> that does not have any <strong>EDIFPortInst</strong>s i.e. is an empty <strong>EDIFNet</strong>. The code for this is given below.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">cleanEmptyNets</span><span class="p">(</span><span class="n">topCell</span><span class="p">):</span>
    <span class="n">nets</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">net</span> <span class="ow">in</span> <span class="n">topCell</span><span class="o">.</span><span class="n">getNets</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">net</span><span class="o">.</span><span class="n">getPortInsts</span><span class="p">()):</span>
            <span class="n">nets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">net</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nets</span><span class="p">:</span>
        <span class="n">topCell</span><span class="o">.</span><span class="n">removeNet</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="create-logical-power-nets">Create Logical Power Nets</h3>

<p>In the final pass, we create nets for hard ‘1’ and ‘0’s by connecting appropriate ports to power (VCC) or ground (GND). This represents assigning a fixed boolean value to a port . The code for this, as well as its breakdown, is given below.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">createStaticSourceNets</span><span class="p">(</span><span class="n">jnet</span><span class="p">,</span> <span class="n">topCell</span><span class="p">,</span> <span class="n">netlist</span><span class="p">):</span>
    <span class="n">topModule</span> <span class="o">=</span> <span class="n">topCell</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span>
    <span class="n">gnd</span> <span class="o">=</span> <span class="n">EDIFTools</span><span class="o">.</span><span class="n">getStaticNet</span><span class="p">(</span><span class="n">NetType</span><span class="o">.</span><span class="n">GND</span><span class="p">,</span> <span class="n">topCell</span><span class="p">,</span> <span class="n">netlist</span><span class="p">);</span>
    <span class="n">vcc</span> <span class="o">=</span> <span class="n">EDIFTools</span><span class="o">.</span><span class="n">getStaticNet</span><span class="p">(</span><span class="n">NetType</span><span class="o">.</span><span class="n">VCC</span><span class="p">,</span> <span class="n">topCell</span><span class="p">,</span> <span class="n">netlist</span><span class="p">);</span>
    <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">jnet</span><span class="p">[</span><span class="s">'modules'</span><span class="p">][</span><span class="n">topModule</span><span class="p">][</span><span class="s">"cells"</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">port</span> <span class="ow">in</span> <span class="n">jnet</span><span class="p">[</span><span class="s">'modules'</span><span class="p">][</span><span class="n">topModule</span><span class="p">][</span><span class="s">"cells"</span><span class="p">][</span><span class="n">cell</span><span class="p">][</span><span class="s">'connections'</span><span class="p">]:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">jnet</span><span class="p">[</span><span class="s">'modules'</span><span class="p">][</span><span class="n">topModule</span><span class="p">][</span><span class="s">"cells"</span><span class="p">][</span><span class="n">cell</span><span class="p">][</span><span class="s">'connections'</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">port</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">"0"</span><span class="p">:</span>
                <span class="n">gnd</span><span class="o">.</span><span class="n">createPortInst</span><span class="p">(</span><span class="n">port</span> <span class="p">,</span> <span class="n">topCell</span><span class="o">.</span><span class="n">getCellInst</span><span class="p">(</span><span class="n">cell</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">"1"</span><span class="p">:</span>
                <span class="n">vcc</span><span class="o">.</span><span class="n">createPortInst</span><span class="p">(</span><span class="n">port</span> <span class="p">,</span> <span class="n">topCell</span><span class="o">.</span><span class="n">getCellInst</span><span class="p">(</span><span class="n">cell</span><span class="p">))</span>
</code></pre></div></div>

<p>The inputs to our routine are the imported JSON file <code class="highlighter-rouge">jnet</code>, the <strong>EDIFCell</strong> <code class="highlighter-rouge">topCell</code> that we are building, and the <strong>EDIFNetlist</strong> <code class="highlighter-rouge">netlist</code>. We will use <code class="highlighter-rouge">netlist</code> and <code class="highlighter-rouge">topCell</code> to create the VCC and GND <strong>EDIFNet</strong>s, and then create and add <strong>EDIFPortInst</strong>s to them  (where applicable).  Note that it is not necessary to pass both <code class="highlighter-rouge">topCell</code> and <code class="highlighter-rouge">netlist</code> since they can reference each other using inbuilt routines.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">createStaticSourceNets</span><span class="p">(</span><span class="n">jnet</span><span class="p">,</span> <span class="n">topCell</span><span class="p">,</span> <span class="n">netlist</span><span class="p">):</span>
</code></pre></div></div>

<p>We begin by getting the name of the top module in our Verilog code.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">topModule</span> <span class="o">=</span> <span class="n">topCell</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span>
</code></pre></div></div>

<p>Next we use the <code class="highlighter-rouge">getStaticNet()</code> routine in the <strong>EDIFTools</strong> class to create two separate <strong>EDIFNet</strong>s for “GND” and “VCC”.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">gnd</span> <span class="o">=</span> <span class="n">EDIFTools</span><span class="o">.</span><span class="n">getStaticNet</span><span class="p">(</span><span class="n">NetType</span><span class="o">.</span><span class="n">GND</span><span class="p">,</span> <span class="n">topCell</span><span class="p">,</span> <span class="n">netlist</span><span class="p">);</span>
    <span class="n">vcc</span> <span class="o">=</span> <span class="n">EDIFTools</span><span class="o">.</span><span class="n">getStaticNet</span><span class="p">(</span><span class="n">NetType</span><span class="o">.</span><span class="n">VCC</span><span class="p">,</span> <span class="n">topCell</span><span class="p">,</span> <span class="n">netlist</span><span class="p">);</span>
</code></pre></div></div>

<p>Similar to how we created <strong>EDIFPortInst</strong>s in the first pass, we will loop over all ports of all cells in <code class="highlighter-rouge">topModule</code>. We do not need to keep track of the “port,cell” tuple since we will go over each port only once, and a port cannot be part of both the VCC and GND nets (since this will lead to a short circuit).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">jnet</span><span class="p">[</span><span class="s">'modules'</span><span class="p">][</span><span class="n">topModule</span><span class="p">][</span><span class="s">"cells"</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">port</span> <span class="ow">in</span> <span class="n">jnet</span><span class="p">[</span><span class="s">'modules'</span><span class="p">][</span><span class="n">topModule</span><span class="p">][</span><span class="s">"cells"</span><span class="p">][</span><span class="n">cell</span><span class="p">][</span><span class="s">'connections'</span><span class="p">]:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">jnet</span><span class="p">[</span><span class="s">'modules'</span><span class="p">][</span><span class="n">topModule</span><span class="p">][</span><span class="s">"cells"</span><span class="p">][</span><span class="n">cell</span><span class="p">][</span><span class="s">'connections'</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">port</span><span class="p">)</span>
</code></pre></div></div>

<p>“GND” and “VCC” nets have a default unique ID of “0” and “1” respectively. We will compare these IDs with the ID stored for the port, and create an <strong>EDIFPortInst</strong> in the appropriate <strong>EDIFNet</strong> if the IDs match.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">"0"</span><span class="p">:</span>
                <span class="n">gnd</span><span class="o">.</span><span class="n">createPortInst</span><span class="p">(</span><span class="n">port</span> <span class="p">,</span> <span class="n">topCell</span><span class="o">.</span><span class="n">getCellInst</span><span class="p">(</span><span class="n">cell</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">"1"</span><span class="p">:</span>
                <span class="n">vcc</span><span class="o">.</span><span class="n">createPortInst</span><span class="p">(</span><span class="n">port</span> <span class="p">,</span> <span class="n">topCell</span><span class="o">.</span><span class="n">getCellInst</span><span class="p">(</span><span class="n">cell</span><span class="p">))</span>
</code></pre></div></div>

<h3 id="putting-it-all-together">Putting It All Together</h3>

<p>Finally, we put all the routines developed in this Step into a single <code class="highlighter-rouge">read_json()</code> routine that takes the JSON file name (<code class="highlighter-rouge">filename</code>), Verilog top module name (<code class="highlighter-rouge">topModule</code>), and device name (<code class="highlighter-rouge">device</code>) as inputs. The <code class="highlighter-rouge">read_json()</code> routine: i) creates our  <strong>Design</strong> (<code class="highlighter-rouge">design</code>) by calling the <strong>Design</strong> constructor, ii) builds the logical netlist for <code class="highlighter-rouge">design</code> by using the routines developed in this Step, and iii) returns <code class="highlighter-rouge">design</code> which now has the complete logical netlist.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">read_json</span> <span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">topModule</span><span class="p">,</span> <span class="n">device</span><span class="p">):</span>
    <span class="n">jnet</span> <span class="o">=</span> <span class="n">read_file</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">design</span> <span class="o">=</span> <span class="n">Design</span><span class="p">(</span><span class="n">topModule</span><span class="p">,</span><span class="n">device</span><span class="p">)</span>
    <span class="n">netlist</span> <span class="o">=</span> <span class="n">design</span><span class="o">.</span><span class="n">getNetlist</span><span class="p">()</span>
    <span class="n">topCell</span> <span class="o">=</span> <span class="n">netlist</span><span class="o">.</span><span class="n">getTopCell</span><span class="p">()</span>
    <span class="n">library</span> <span class="o">=</span> <span class="n">netlist</span><span class="o">.</span><span class="n">getLibrary</span><span class="p">(</span><span class="s">"hdi_primitives"</span><span class="p">)</span>
    <span class="n">buildLibrary</span><span class="p">(</span><span class="n">jnet</span><span class="p">,</span> <span class="n">library</span><span class="p">)</span>
    <span class="n">defineExternalPorts</span><span class="p">(</span><span class="n">jnet</span><span class="p">,</span> <span class="n">topCell</span><span class="p">)</span>    
    <span class="n">createEDIFCellInsts</span><span class="p">(</span><span class="n">jnet</span><span class="p">,</span> <span class="n">topCell</span><span class="p">,</span> <span class="n">library</span><span class="p">)</span>
    <span class="n">createEDIFPorts</span><span class="p">(</span><span class="n">jnet</span><span class="p">,</span> <span class="n">topCell</span><span class="p">)</span>
    <span class="n">cleanEmptyNets</span><span class="p">(</span><span class="n">topCell</span><span class="p">)</span>
    <span class="n">createStaticSourceNets</span><span class="p">(</span><span class="n">jnet</span><span class="p">,</span> <span class="n">topCell</span><span class="p">,</span><span class="n">netlist</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">design</span>
</code></pre></div></div>

<p>At this point, we can use Vivado to verify that the netlist was created correctly by writing out an EDIF or Design Check Point file from RapidWright. From Step 2 onwards, we will be building the physical netlist.</p>

<h2 id="step-2-placing-io-buffers">Step 2: Placing IO Buffers</h2>

<p>We begin the process of building the physical netlist by placing the IO buffers for external ports. Unlike other components in the netlist, I/O Buffers must be placed at very specific location, given by the chip pins to which their corresponding ports are connected. The code for placing I/O buffers, as well as its breakdown, is given below.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">placeIOBuffers</span><span class="p">(</span><span class="n">design</span> <span class="p">,</span> <span class="n">constraints</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">pin</span> <span class="ow">in</span> <span class="n">constraints</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">topnets</span> <span class="ow">in</span> <span class="n">design</span><span class="o">.</span><span class="n">getNetlist</span><span class="p">()</span><span class="o">.</span><span class="n">getTopCell</span><span class="p">()</span><span class="o">.</span><span class="n">getNets</span><span class="p">()</span><span class="o">.</span><span class="n">toArray</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">pin</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">topnets</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">cellName</span> <span class="ow">in</span> <span class="n">design</span><span class="o">.</span><span class="n">getNetlist</span><span class="p">()</span><span class="o">.</span><span class="n">getTopCell</span><span class="p">()</span><span class="o">.</span><span class="n">getCellInsts</span><span class="p">()</span><span class="o">.</span><span class="n">toArray</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">():</span>
                    <span class="k">if</span> <span class="p">(</span><span class="s">"IBUF"</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">cellName</span><span class="o">.</span><span class="n">getCellType</span><span class="p">()))</span> <span class="ow">or</span> <span class="p">(</span><span class="s">"OBUF"</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">cellName</span><span class="o">.</span><span class="n">getCellType</span><span class="p">())):</span>
                        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">topnets</span><span class="o">.</span><span class="n">getPortInstMap</span><span class="p">():</span>
                            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">cellName</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">entry</span><span class="p">):</span>
                                <span class="n">ret</span> <span class="o">=</span> <span class="n">design</span><span class="o">.</span><span class="n">placeIOB</span><span class="p">(</span><span class="n">cellName</span><span class="p">,</span> <span class="n">constraints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">'LOC'</span><span class="p">),</span> <span class="n">constraints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">'IOSTANDARD'</span><span class="p">))</span>
                                <span class="n">ret</span><span class="o">.</span><span class="n">addProperty</span><span class="p">(</span><span class="s">"IOSTANDARD"</span><span class="p">,</span><span class="n">constraints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">"IOSTANDARD"</span><span class="p">))</span>
                                <span class="n">ret</span><span class="o">.</span><span class="n">addProperty</span><span class="p">(</span><span class="s">"SLEW"</span><span class="p">,</span><span class="n">constraints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">"SLEW"</span><span class="p">))</span>
                                <span class="n">ret</span><span class="o">.</span><span class="n">addProperty</span><span class="p">(</span><span class="s">"IN_TERM"</span><span class="p">,</span><span class="n">constraints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">"IN_TERM"</span><span class="p">))</span>
                                <span class="n">ret</span><span class="o">.</span><span class="n">addProperty</span><span class="p">(</span><span class="s">"PULL_TYPE"</span><span class="p">,</span><span class="n">constraints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">"PULL_TYPE"</span><span class="p">))</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">placeIOB()</code> routine in design requires three inputs to place a I/O buffer component: i) the <strong>EDIFCellInst</strong> for the buffer, ii) the chip package pin it corresponds to, and iii) the IO Standard. Information for (ii) and (iii) is provided by the user in the <code class="highlighter-rouge">constraints</code> object from Step 0. We only need to get the <strong>EDIFCellInst</strong>.</p>

<p>Doing so requires knowledge of how the I/O <em>Sites</em> in Xilinx 7-Series FPGAs are structured (shown in the image below). The specific <strong>EDIFCellInst</strong> we are interested in connects to the chip pin’s <em>PAD</em> using a single <strong>SiteWire</strong>. If we can find the <strong>EDIFNet</strong> corresponding to this connection, we can find the two <strong>EDIFPortInst</strong>s in this <strong>EDIFNet</strong>. And once we know the <strong>EDIFPortInst</strong>s, we can get the <strong>EDIFCellInst</strong>s they belong to. Note that since the chip pin’s <em>PAD</em> is not connected to an <strong>EDIFCellInst</strong>, there will be only one result in our search. Let’s look at how this will be done using RapidWright APIs.</p>

<p><img src="/images/blog/PNR/basic-hardware-generation/iopad.PNG" alt="Xilinx 7-Series IO PAD" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">placeIOBuffers</span><span class="p">(</span><span class="n">design</span> <span class="p">,</span> <span class="n">constraints</span><span class="p">):</span>
</code></pre></div></div>

<p>The first challenge is to find the name of the <strong>EDIFNet</strong>s. To do this, we leverage the observation that Yosys uses the name of the chip pin’s <em>PAD</em> as the name for the corresponding <strong>EDIFNet</strong>. This is also the name of the pin in the <code class="highlighter-rouge">constraints</code> object. Therefore, if a name exists in both as a <code class="highlighter-rouge">key</code> in the <code class="highlighter-rouge">constraints</code> and as an <strong>EDIFNet</strong> in the <strong>EDIFCell</strong>, then we will process the <strong>EDIFNet</strong>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">for</span> <span class="n">pin</span> <span class="ow">in</span> <span class="n">constraints</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">topnets</span> <span class="ow">in</span> <span class="n">design</span><span class="o">.</span><span class="n">getNetlist</span><span class="p">()</span><span class="o">.</span><span class="n">getTopCell</span><span class="p">()</span><span class="o">.</span><span class="n">getNets</span><span class="p">()</span><span class="o">.</span><span class="n">toArray</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">pin</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">topnets</span><span class="p">):</span>
</code></pre></div></div>

<p>For the <strong>EDIFNet</strong> selected, we run a nested loop which loops over all <strong>EDIFPortInst</strong>s and all <em>I/O Buffer</em> <strong>EDIFCellInst</strong>s. To find if an <strong>EDIFCellInst</strong> is an <em>I/O Buffer</em>, we look for <code class="highlighter-rouge">IBUF</code> and <code class="highlighter-rouge">OBUF</code> <strong>EDIFCell</strong> types. Note that this <code class="highlighter-rouge">if</code> condition is not necessary since we will be matching names, but it helps reduce the number of <strong>EDIFCellInst</strong>s we have to check - the total number of <strong>EDIFCellInst</strong>s can be many orders of magnitude higher than just the <em>I/O Buffer</em> ones.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                <span class="k">for</span> <span class="n">cellName</span> <span class="ow">in</span> <span class="n">design</span><span class="o">.</span><span class="n">getNetlist</span><span class="p">()</span><span class="o">.</span><span class="n">getTopCell</span><span class="p">()</span><span class="o">.</span><span class="n">getCellInsts</span><span class="p">()</span><span class="o">.</span><span class="n">toArray</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">():</span>
                    <span class="k">if</span> <span class="p">(</span><span class="s">"IBUF"</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">cellName</span><span class="o">.</span><span class="n">getCellType</span><span class="p">()))</span> <span class="ow">or</span> <span class="p">(</span><span class="s">"OBUF"</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">cellName</span><span class="o">.</span><span class="n">getCellType</span><span class="p">())):</span>
                        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">topnets</span><span class="o">.</span><span class="n">getPortInstMap</span><span class="p">():</span>
</code></pre></div></div>
<p>For each <strong>EDIFCellInst</strong> and <strong>EDIFPortInst</strong> pair we pick up, we leverage the observation that converting the <strong>EDIFPortInst</strong> to a string will give us the name of its <strong>EDIFCellInst</strong>.  Note that we could also do this in more steps (and more efficiently) by using appropriate APIs to get the <strong>EDIFCellInst</strong> itself from the <strong>EDIFPortInst</strong>, followed by <code class="highlighter-rouge">getName()</code> calls.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">cellName</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">entry</span><span class="p">):</span>                  
</code></pre></div></div>
<p>If all conditions are met, we have the <strong>EDIFCellInst</strong>. We can then go ahead and place the <strong>EDICellInst</strong> at the location given in <code class="highlighter-rouge">constraints</code>. The <code class="highlighter-rouge">placeIOB()</code> routine both creates a new <strong>Cell</strong> for this placed buffer in <strong>Design</strong> and returns it. The returned <strong>Cell</strong> is placed in <code class="highlighter-rouge">ret</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                                <span class="n">ret</span> <span class="o">=</span> <span class="n">design</span><span class="o">.</span><span class="n">placeIOB</span><span class="p">(</span><span class="n">cellName</span><span class="p">,</span> <span class="n">constraints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">'LOC'</span><span class="p">),</span> <span class="n">constraints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">'IOSTANDARD'</span><span class="p">))</span>
</code></pre></div></div>

<p>Finally, we call the <code class="highlighter-rouge">addProperty()</code> routines in the <strong>Cell</strong> to add the remaining properties in the <code class="highlighter-rouge">constraints</code> object.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                                <span class="n">ret</span><span class="o">.</span><span class="n">addProperty</span><span class="p">(</span><span class="s">"IOSTANDARD"</span><span class="p">,</span><span class="n">constraints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">"IOSTANDARD"</span><span class="p">))</span>
                                <span class="n">ret</span><span class="o">.</span><span class="n">addProperty</span><span class="p">(</span><span class="s">"SLEW"</span><span class="p">,</span><span class="n">constraints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">"SLEW"</span><span class="p">))</span>
                                <span class="n">ret</span><span class="o">.</span><span class="n">addProperty</span><span class="p">(</span><span class="s">"IN_TERM"</span><span class="p">,</span><span class="n">constraints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">"IN_TERM"</span><span class="p">))</span>
                                <span class="n">ret</span><span class="o">.</span><span class="n">addProperty</span><span class="p">(</span><span class="s">"PULL_TYPE"</span><span class="p">,</span><span class="n">constraints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">"PULL_TYPE"</span><span class="p">))</span>
</code></pre></div></div>

<h2 id="step-3-place---using-a-random-placer-algorithm">Step 3: Place - Using A Random Placer Algorithm</h2>
<p>The next step is placing the remaining <strong>EDIFCellInst</strong>s on the chip. An exception to this is <strong>EDIFCellInst</strong>s of types <em>VCC</em> and <em>GND</em>. This is because there is no one specific location for them; there are <strong>BEL</strong>s throughput the chip which have <em>HARD 1</em> (VCC) and <em>HARD 0</em> (GND) pins. Thus, to provide VCC and GND connections, a placement operation is not necessary and we only need to ensure that their corresponding <strong>Net</strong>s are routed properly.</p>

<p>We will be using the simplest placement algorithm for this part i.e. a random placer. Moreover, also for simplicity, we will not be doing any packing for this design. The code and its breakdown is given below. Note that we have currently hardcoded support for the different technologies used in our design i.e. IBUF, OBUF, BUFGCTRL, LUT and FDRE - it may be possible to replace our approach with a combination of RapidWright APIs that can automatically derive the <strong>SiteTypeEnum</strong> for a given technology e.g. SLICEL or SLICEM for FDRE. Also note that we have hardcoded the placement of BUFGCTRL. This is because the design is sufficiently constrained by the clock pin for us to know which of the vertical clock buffers we should be using.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">placeCells</span><span class="p">(</span><span class="n">design</span><span class="p">):</span>
    <span class="n">cell_Names</span> <span class="o">=</span> <span class="n">design</span><span class="o">.</span><span class="n">getNetlist</span><span class="p">()</span><span class="o">.</span><span class="n">getTopCell</span><span class="p">()</span><span class="o">.</span><span class="n">getCellInsts</span><span class="p">()</span><span class="o">.</span><span class="n">toArray</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">placement_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">cn</span> <span class="ow">in</span> <span class="n">cell_Names</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="s">"GND"</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">cn</span><span class="o">.</span><span class="n">getCellType</span><span class="p">()))</span> <span class="ow">or</span> <span class="p">(</span><span class="s">"VCC"</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">cn</span><span class="o">.</span><span class="n">getCellType</span><span class="p">())):</span>
             <span class="k">continue</span>

        <span class="k">elif</span> <span class="p">(</span><span class="s">"IBUF"</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">cn</span><span class="o">.</span><span class="n">getCellType</span><span class="p">()))</span> <span class="ow">or</span> <span class="p">(</span><span class="s">"OBUF"</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">cn</span><span class="o">.</span><span class="n">getCellType</span><span class="p">())):</span>
            <span class="k">continue</span>

        <span class="k">elif</span> <span class="p">(</span><span class="s">"BUFGCTRL"</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">cn</span><span class="o">.</span><span class="n">getCellType</span><span class="p">())):</span>
            <span class="n">cell</span> <span class="o">=</span> <span class="n">design</span><span class="o">.</span><span class="n">createCell</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">cn</span><span class="p">),</span><span class="n">cn</span><span class="p">)</span>
            <span class="n">site</span> <span class="o">=</span> <span class="n">design</span><span class="o">.</span><span class="n">getDevice</span><span class="p">()</span><span class="o">.</span><span class="n">getSite</span><span class="p">(</span><span class="s">"BUFGCTRL_X0Y16"</span><span class="p">)</span>
            <span class="n">bel</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">getBEL</span><span class="p">(</span><span class="s">"BUFGCTRL"</span><span class="p">)</span>
            <span class="n">design</span><span class="o">.</span><span class="n">placeCell</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span><span class="n">site</span><span class="p">,</span><span class="n">bel</span><span class="p">)</span>

        <span class="k">elif</span> <span class="p">(</span><span class="s">"LUT"</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">cn</span><span class="o">.</span><span class="n">getCellType</span><span class="p">())</span> <span class="ow">or</span> <span class="s">"FDRE"</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">cn</span><span class="o">.</span><span class="n">getCellType</span><span class="p">())):</span>
            <span class="n">cell</span> <span class="o">=</span> <span class="n">design</span><span class="o">.</span><span class="n">createCell</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">cn</span><span class="p">),</span><span class="n">cn</span><span class="p">)</span>
            <span class="n">bels</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">getCompatiblePlacements</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">SiteTypeEnum</span><span class="o">.</span><span class="n">SLICEL</span><span class="p">)</span>
            <span class="n">sites</span> <span class="o">=</span> <span class="n">design</span><span class="o">.</span><span class="n">getDevice</span><span class="p">()</span><span class="o">.</span><span class="n">getAllCompatibleSites</span><span class="p">(</span><span class="n">SiteTypeEnum</span><span class="o">.</span><span class="n">SLICEL</span><span class="p">)</span>    
            <span class="n">running</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">running</span><span class="p">:</span>
                <span class="n">bel_name</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">bels</span><span class="p">)[</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">bels</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
                <span class="n">site</span> <span class="o">=</span> <span class="n">sites</span><span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
                <span class="n">bel</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">getBEL</span><span class="p">(</span><span class="n">bel_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">site</span><span class="p">)</span><span class="o">+</span><span class="s">"/"</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">bel</span><span class="p">))</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">placement_list</span><span class="p">:</span>
                    <span class="n">placement_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">site</span><span class="p">)</span><span class="o">+</span><span class="s">"/"</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">bel</span><span class="p">)))</span> 
                    <span class="n">running</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">design</span><span class="o">.</span><span class="n">placeCell</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span><span class="n">site</span><span class="p">,</span><span class="n">bel</span><span class="p">)</span>
</code></pre></div></div>

<p>Since we will be creating and placing <strong>Cell</strong>s in <strong>Design</strong>, we pass <strong>Design</strong> as the input to the <code class="highlighter-rouge">placeCells()</code> routine.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">placeCells</span><span class="p">(</span><span class="n">design</span><span class="p">):</span>
</code></pre></div></div>

<p>As discussed above, we are going to loop over all <strong>EDIFCellInst</strong>s. To track locations which have been used, we also initialize <code class="highlighter-rouge">placement_list</code>; this list will contain <strong>Site</strong>/<strong>BEL</strong> tuples which are not available to an <strong>EDIFCellInst</strong>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">cell_Names</span> <span class="o">=</span> <span class="n">design</span><span class="o">.</span><span class="n">getNetlist</span><span class="p">()</span><span class="o">.</span><span class="n">getTopCell</span><span class="p">()</span><span class="o">.</span><span class="n">getCellInsts</span><span class="p">()</span><span class="o">.</span><span class="n">toArray</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">placement_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">cn</span> <span class="ow">in</span> <span class="n">cell_Names</span><span class="p">:</span>
</code></pre></div></div>

<p>Within the loop, we start by skipping <strong>EDIFCellInst</strong>s of type <em>GND</em>, <em>VCC</em>, <em>IBUF</em> and <em>OBUF</em>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">if</span> <span class="p">(</span><span class="s">"GND"</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">cn</span><span class="o">.</span><span class="n">getCellType</span><span class="p">()))</span> <span class="ow">or</span> <span class="p">(</span><span class="s">"VCC"</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">cn</span><span class="o">.</span><span class="n">getCellType</span><span class="p">())):</span>
             <span class="k">continue</span>

        <span class="k">elif</span> <span class="p">(</span><span class="s">"IBUF"</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">cn</span><span class="o">.</span><span class="n">getCellType</span><span class="p">()))</span> <span class="ow">or</span> <span class="p">(</span><span class="s">"OBUF"</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">cn</span><span class="o">.</span><span class="n">getCellType</span><span class="p">())):</span>
            <span class="k">continue</span>
</code></pre></div></div>

<p>Next, we place the <code class="highlighter-rouge">BUFGCTRL</code> in our design. Note that since we have single clock source, there will only be one such <strong>EDIFCellInst</strong> (although it is possible for us to manually instantiate more - in which case we would apply the algorithm for <code class="highlighter-rouge">LUT</code> and <code class="highlighter-rouge">FDRE</code> (given below) here as well.</p>

<p>We do the placement with a four step approach. First, we create a <strong>Cell</strong> in the design using the <strong>EDIFCellInst</strong>. Doing so ensures that the <strong>Cell</strong> inherits all properties of the <strong>EDIFCellInst</strong>, and greatly simplifies the complexity of <strong>Cell</strong> creation. Next, we create a <strong>Site</strong> where this <strong>Cell</strong> can be placed - in this case, we create a <strong>Site</strong> for <code class="highlighter-rouge">BUFGCTRL_X0Y16</code>.  Next, we select a <strong>BEL</strong> within the <strong>Site</strong> which can implement this <strong>Cell</strong> - in Xilinx 7-Series, this will always be the <code class="highlighter-rouge">BUFGCTRL</code> <strong>BEL</strong>. Finally, we call <code class="highlighter-rouge">placeCell</code> in <strong>Design</strong> to placed the <strong>Cell</strong> <code class="highlighter-rouge">cell</code> and the <strong>Site</strong> <code class="highlighter-rouge">site</code> and <strong>BEL</strong> <code class="highlighter-rouge">bel</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">elif</span> <span class="p">(</span><span class="s">"BUFGCTRL"</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">cn</span><span class="o">.</span><span class="n">getCellType</span><span class="p">())):</span>
            <span class="n">cell</span> <span class="o">=</span> <span class="n">design</span><span class="o">.</span><span class="n">createCell</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">cn</span><span class="p">),</span><span class="n">cn</span><span class="p">)</span>
            <span class="n">site</span> <span class="o">=</span> <span class="n">design</span><span class="o">.</span><span class="n">getDevice</span><span class="p">()</span><span class="o">.</span><span class="n">getSite</span><span class="p">(</span><span class="s">"BUFGCTRL_X0Y16"</span><span class="p">)</span>
            <span class="n">bel</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">getBEL</span><span class="p">(</span><span class="s">"BUFGCTRL"</span><span class="p">)</span>
            <span class="n">design</span><span class="o">.</span><span class="n">placeCell</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span><span class="n">site</span><span class="p">,</span><span class="n">bel</span><span class="p">)</span>
</code></pre></div></div>

<p>Doing placement for <code class="highlighter-rouge">LUT</code> and <code class="highlighter-rouge">FDRE</code> <strong>EDIFCellInst</strong>s is essentially the same steps as we saw for <code class="highlighter-rouge">BUFGCTRL</code> above. However, in this case, we will not hardcode the <strong>Site</strong> and <strong>BEL</strong> locations. To be able to leverage certain RapidWright APIs to find compatible location, it is critical that a valid <strong>Device</strong> has been added to <strong>Design</strong> - otherwise, these routines will fail.</p>

<p>The first step is again to create a <strong>Cell</strong> using the <strong>EDIFCellInst</strong>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">elif</span> <span class="p">(</span><span class="s">"LUT"</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">cn</span><span class="o">.</span><span class="n">getCellType</span><span class="p">())</span> <span class="ow">or</span> <span class="s">"FDRE"</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">cn</span><span class="o">.</span><span class="n">getCellType</span><span class="p">())):</span>
            <span class="n">cell</span> <span class="o">=</span> <span class="n">design</span><span class="o">.</span><span class="n">createCell</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">cn</span><span class="p">),</span><span class="n">cn</span><span class="p">)</span>
</code></pre></div></div>

<p>Next, we get a list of possible <strong>BEL</strong>s where this <strong>Cell</strong> can be placed. This can be done by first calling the <code class="highlighter-rouge">getCompatiblePlacements()</code> routine in <strong>Cell</strong>, and then filtering the results based on the target <strong>Site</strong> type. For now, we have hardcoded the <strong>SiteTypeEnum</strong> to be <code class="highlighter-rouge">SLICEL</code> since this type of <strong>Site</strong> can implement look up tables, flip flops and carry chains. Note that a <strong>BEL</strong> does not store location data. This means that <code class="highlighter-rouge">bels</code> will not contain every compatible <strong>BEL</strong> in every <code class="highlighter-rouge">SLICEL</code> on the chip - rather, it will only be a list of unique <strong>BEL</strong>s that will exist in any <code class="highlighter-rouge">SLICEL</code> <strong>Site</strong>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="n">bels</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">getCompatiblePlacements</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">SiteTypeEnum</span><span class="o">.</span><span class="n">SLICEL</span><span class="p">)</span>
</code></pre></div></div>

<p>Next, get a list of possible <strong>Site</strong>s where this <strong>Cell</strong> can be placed. We again using <code class="highlighter-rouge">SLICEL</code> as the type, but now call the <code class="highlighter-rouge">getAllCompatibleSites()</code> routine in <strong>Design</strong>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="n">sites</span> <span class="o">=</span> <span class="n">design</span><span class="o">.</span><span class="n">getDevice</span><span class="p">()</span><span class="o">.</span><span class="n">getAllCompatibleSites</span><span class="p">(</span><span class="n">SiteTypeEnum</span><span class="o">.</span><span class="n">SLICEL</span><span class="p">)</span> 
</code></pre></div></div>

<p>Now that we have list of potential <strong>BEL</strong>s and <strong>Site</strong>s, let’s randomly pick a <strong>Site</strong>/<strong>Bell</strong> tuple. We do this inside a <code class="highlighter-rouge">while</code> loop so that we can keep picking tuples till we find an unassigned one.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="n">running</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">running</span><span class="p">:</span>
                <span class="n">bel_name</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">bels</span><span class="p">)[</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">bels</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
                <span class="n">site</span> <span class="o">=</span> <span class="n">sites</span><span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
                <span class="n">bel</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">getBEL</span><span class="p">(</span><span class="n">bel_name</span><span class="p">)</span>
</code></pre></div></div>

<p>If the tuple is not already in <code class="highlighter-rouge">placement_list</code>, we can use it to place the <strong>Cell</strong> <code class="highlighter-rouge">cell</code>. We also append it to <code class="highlighter-rouge">placement_list</code> to indicate that it has now been assigned.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">site</span><span class="p">)</span><span class="o">+</span><span class="s">"/"</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">bel</span><span class="p">))</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">placement_list</span><span class="p">:</span>
                    <span class="n">placement_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">site</span><span class="p">)</span><span class="o">+</span><span class="s">"/"</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">bel</span><span class="p">)))</span> 
                    <span class="n">running</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">design</span><span class="o">.</span><span class="n">placeCell</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span><span class="n">site</span><span class="p">,</span><span class="n">bel</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="step-4-create-physical-un-routed-nets-from-logical-netlist">Step 4: Create Physical (Un-Routed) Nets from Logical Netlist</h2>
<p>Now that we have created and placed our <strong>Cell</strong>s, lets create the physical <strong>Net</strong>s that will connect them together using information provided by the <strong>EDIFNet</strong>s in our <strong>EDIFCell</strong> <code class="highlighter-rouge">topCell</code>. We will use three routines for this.</p>

<h3 id="external-port-check">External Port Check</h3>
<p>The first routine checks if a <strong>Net</strong> corresponds to the <em>PAD</em> - <em>I/O Buffer</em> connection we discussed in Step 2.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">checkIfTopPort</span><span class="p">(</span><span class="n">topCell</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">topCell</span><span class="o">.</span><span class="n">getPortMap</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span> <span class="k">return</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="mi">0</span>
</code></pre></div></div>

<h3 id="create-net-objects">Create Net Objects</h3>
<p>The next routine is used to create <strong>Net</strong>s using the remaining <strong>EDIFNet</strong>s. Note that doing so will only initialize some basic variables within the <strong>Net</strong>, such as its name. Other information, such as the physical pins corresponding to <strong>EDIFPortInst</strong>s in an <strong>EDIFNet</strong> cannot be automatically derived - they require a separate routine as we will implement later. The code for this is given below.</p>

<p>The routine takes as input the <strong>Design</strong>. For each <strong>EDIFNet</strong> in the <strong>EDIFCell</strong> <code class="highlighter-rouge">topCell</code>, we first remove the corresponding <strong>Net</strong> if it already exists, and then we call <code class="highlighter-rouge">createNet()</code> to create a <strong>Net</strong> if the <strong>EDIFNet</strong> is not a <em>PAD</em> - <em>I/O Buffer</em> connection and if it does not correspond to a <em>VCC</em> or <em>GND</em> connection.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">createNets</span><span class="p">(</span><span class="n">design</span><span class="p">):</span>
    <span class="n">netlist</span> <span class="o">=</span> <span class="n">design</span><span class="o">.</span><span class="n">getNetlist</span><span class="p">()</span>
    <span class="n">topCell</span> <span class="o">=</span> <span class="n">netlist</span><span class="o">.</span><span class="n">getTopCell</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">design</span><span class="o">.</span><span class="n">getNets</span><span class="p">()</span><span class="o">.</span><span class="n">toArray</span><span class="p">():</span>
        <span class="n">design</span><span class="o">.</span><span class="n">removeNet</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">topCell</span><span class="o">.</span><span class="n">getNets</span><span class="p">()</span><span class="o">.</span><span class="n">toArray</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">checkIfTopPort</span><span class="p">(</span><span class="n">topCell</span><span class="p">,</span><span class="n">i</span><span class="p">):</span> <span class="k">continue</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">EDIFTools</span><span class="o">.</span><span class="n">getStaticNet</span><span class="p">(</span><span class="n">NetType</span><span class="o">.</span><span class="n">VCC</span><span class="p">,</span> <span class="n">topCell</span><span class="p">,</span> <span class="n">netlist</span><span class="p">):</span> <span class="k">continue</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">EDIFTools</span><span class="o">.</span><span class="n">getStaticNet</span><span class="p">(</span><span class="n">NetType</span><span class="o">.</span><span class="n">GND</span><span class="p">,</span> <span class="n">topCell</span><span class="p">,</span> <span class="n">netlist</span><span class="p">):</span> <span class="k">continue</span> 
        <span class="n">design</span><span class="o">.</span><span class="n">createNet</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="create-pin-objects-for-each-net-object">Create Pin Objects For Each Net Object</h3>
<p>The last routine adds <strong>SitePinInst</strong>s to each <strong>Net</strong>. Note that a <strong>Net</strong> connects pins of <em>Site</em>s, not <em>BEL</em>s - as discussed above, <strong>Cell</strong>s are implemented as <strong>BEL</strong>s, and there are be multiple <strong>BEL</strong>s in a single <strong>Site</strong>. Therefore, as we can see from the diagram below of a basic logic block in the Xilinx 7-Series architecture, not all <em>BEL</em> pins are directly connected to <em>Site</em> pins. The total number of <em>Site</em> pins is less than the total number of <em>BEL</em> pins, making it impossible to connect all <em>BEL</em> pins to <em>Site</em> pins simultaneously. This is why packing is a critical process: it increases the number of intra-<em>Site</em> connections so that fewer <em>BEL</em> pins that need access to <em>Site</em> pins, and thus results in higher utilization of a logic block.</p>

<p><img src="/images/blog/PNR/basic-hardware-generation/logic_block_xilinx_7_series.PNG" alt="Xilinx 7-Series Logic Block" /></p>

<p>To multiplex the limited <em>Site</em> pins, a large number of MUXs (also known as <em>Routing BELs</em>) are implemented in a logic block. By setting the appropriate <strong>SitePIP</strong> (discussed earlier) for a <em>Routing BEL</em>, we can connect a <em>BEL</em> pin to a <em>Site</em> pin, and then add the corresponding <strong>SitePinInst</strong> for this <em>Site</em> pin to the <strong>Net</strong>. The code and its breakdown is given below.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">createNetPins</span><span class="p">(</span><span class="n">design</span><span class="p">):</span>
    <span class="n">netlist</span> <span class="o">=</span> <span class="n">design</span><span class="o">.</span><span class="n">getNetlist</span><span class="p">()</span>
    <span class="n">topCell</span> <span class="o">=</span> <span class="n">netlist</span><span class="o">.</span><span class="n">getTopCell</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">physNet</span> <span class="ow">in</span> <span class="n">design</span><span class="o">.</span><span class="n">getNets</span><span class="p">()</span><span class="o">.</span><span class="n">toArray</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">checkIfTopPort</span><span class="p">(</span><span class="n">topCell</span><span class="p">,</span><span class="n">physNet</span><span class="p">):</span> <span class="k">continue</span>
        <span class="n">edifNet</span> <span class="o">=</span> <span class="n">physNet</span><span class="o">.</span><span class="n">getLogicalNet</span><span class="p">()</span>
        <span class="n">portInsts</span> <span class="o">=</span> <span class="n">edifNet</span><span class="o">.</span><span class="n">getPortInsts</span><span class="p">()</span><span class="o">.</span><span class="n">toArray</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">portInst</span> <span class="ow">in</span> <span class="n">portInsts</span><span class="p">:</span>
            <span class="n">portName</span> <span class="o">=</span> <span class="n">portInst</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span>
            <span class="n">portCell</span> <span class="o">=</span> <span class="n">portInst</span><span class="o">.</span><span class="n">getCellInst</span><span class="p">()</span>
            <span class="n">portDir</span> <span class="o">=</span> <span class="n">portInst</span><span class="o">.</span><span class="n">getDirection</span><span class="p">()</span>
            <span class="n">physCell</span> <span class="o">=</span> <span class="n">design</span><span class="o">.</span><span class="n">getCell</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">portCell</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">portInst</span><span class="o">.</span><span class="n">isPrimitiveStaticSource</span><span class="p">():</span> <span class="k">continue</span>
            <span class="n">siteInst</span> <span class="o">=</span> <span class="n">physCell</span><span class="o">.</span><span class="n">getSiteInst</span><span class="p">()</span>
            <span class="n">siteWires</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">physCell</span><span class="o">.</span><span class="n">getSitePinFromPortInst</span><span class="p">(</span><span class="n">portInst</span><span class="p">,</span><span class="n">siteWires</span><span class="p">)</span>            
            <span class="n">physNet</span><span class="o">.</span><span class="n">createPin</span><span class="p">(</span><span class="n">portInst</span><span class="o">.</span><span class="n">isOutput</span><span class="p">(),</span><span class="n">siteWires</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">siteWires</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">siteInst</span><span class="p">)</span>
</code></pre></div></div>

<p>The routine <code class="highlighter-rouge">createNetPins</code> takes the <strong>Design</strong> as input and updates the <strong>Net</strong>s in it.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">createNetPins</span><span class="p">(</span><span class="n">design</span><span class="p">):</span>
</code></pre></div></div>

<p>We use the <code class="highlighter-rouge">getNetlist()</code> and <code class="highlighter-rouge">getTopCell()</code> calls to get the <strong>EDIFCell</strong> for a design. Then, we loop over all <strong>Net</strong>s created in the previous routine.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">netlist</span> <span class="o">=</span> <span class="n">design</span><span class="o">.</span><span class="n">getNetlist</span><span class="p">()</span>
    <span class="n">topCell</span> <span class="o">=</span> <span class="n">netlist</span><span class="o">.</span><span class="n">getTopCell</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">physNet</span> <span class="ow">in</span> <span class="n">design</span><span class="o">.</span><span class="n">getNets</span><span class="p">()</span><span class="o">.</span><span class="n">toArray</span><span class="p">():</span>
</code></pre></div></div>

<p>Next, we use our custom <code class="highlighter-rouge">checkIfTopPort()</code> routine from earlier in this Step to determine if we should skip the <strong>Net</strong>. If the <strong>Net</strong> corresponds to <em>PAD</em>-<em>I/O Buffer</em> connectivity, then there is no inter-<em>Site</em> wiring required, and hence the <strong>Net</strong> will not have any <strong>SitePinInst</strong>s.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">if</span> <span class="n">checkIfTopPort</span><span class="p">(</span><span class="n">topCell</span><span class="p">,</span><span class="n">physNet</span><span class="p">):</span> <span class="k">continue</span>
</code></pre></div></div>
<p>If the above condition is not met, we can start adding <strong>SitePinInst</strong>s to this <strong>Net</strong>. To do this, we first get the <strong>EDIFNet</strong> for this <strong>Net</strong>, and then loop over all <strong>EDIFPortInst</strong>s in the <strong>EDIFNet</strong>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="n">edifNet</span> <span class="o">=</span> <span class="n">physNet</span><span class="o">.</span><span class="n">getLogicalNet</span><span class="p">()</span>
        <span class="n">portInsts</span> <span class="o">=</span> <span class="n">edifNet</span><span class="o">.</span><span class="n">getPortInsts</span><span class="p">()</span><span class="o">.</span><span class="n">toArray</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">portInst</span> <span class="ow">in</span> <span class="n">portInsts</span><span class="p">:</span>
</code></pre></div></div>

<p>If the <strong>EDIFPortInst</strong> is static source, i.e. <code class="highlighter-rouge">VCC</code> or <code class="highlighter-rouge">GND</code>, we will skip it.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="k">if</span> <span class="n">portInst</span><span class="o">.</span><span class="n">isPrimitiveStaticSource</span><span class="p">():</span> <span class="k">continue</span>
</code></pre></div></div>

<p>For each non-static source based <strong>EDIFPortInst</strong>, we get the <strong>EDIFCellInst</strong> <code class="highlighter-rouge">portCell</code> to which it is attached, and then from the <strong>EDIFCellInst</strong> we get the corresponding <strong>Cell</strong> <code class="highlighter-rouge">physCell</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="n">portCell</span> <span class="o">=</span> <span class="n">portInst</span><span class="o">.</span><span class="n">getCellInst</span><span class="p">()</span>
            <span class="n">physCell</span> <span class="o">=</span> <span class="n">design</span><span class="o">.</span><span class="n">getCell</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">portCell</span><span class="p">))</span>
</code></pre></div></div>

<p>To create a <strong>SitePinInst</strong>, we need to know the name of the corresponding <em>Site</em> pin. To get this, we call the <code class="highlighter-rouge">getSitePinFromPortInst()</code> routine from <code class="highlighter-rouge">physCell</code>. If an empty list is passed to the routine, <code class="highlighter-rouge">siteWires</code> in our case, then the routine will add to it an ordered list of wires between the <em>BEL</em> pin, and the <em>Site</em> pin it can connect to. The name of the <em>Site</em> pin will be the last entry in this ordered list.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="n">siteWires</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">physCell</span><span class="o">.</span><span class="n">getSitePinFromPortInst</span><span class="p">(</span><span class="n">portInst</span><span class="p">,</span><span class="n">siteWires</span><span class="p">)</span>    
</code></pre></div></div>
<p>From <code class="highlighter-rouge">physCell</code>, we get the <strong>SiteInst</strong>. The formal difference between <strong>SiteInst</strong> and <strong>Site</strong>, according to the RapidWright documentation, is “this class represents the instance of a site as configured by the user design…It differs from the Site class in that it carries configuration data from the user design whereas Site is static and only represents available constructs in the silicon”. Basically, <strong>SiteInst</strong> will have more information based on our design, and this information can be modified (unlike the information in <strong>Site</strong>). We will see this in more detail in the next Step.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="n">siteInst</span> <span class="o">=</span> <span class="n">physCell</span><span class="o">.</span><span class="n">getSiteInst</span><span class="p">()</span>
</code></pre></div></div>
<p>Finally, we call the <code class="highlighter-rouge">createPin()</code> routine in the <strong>Net</strong> using the <strong>EDIFPortInst</strong> direction, the <em>Site</em> pin name, and the <strong>SiteInst</strong>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="n">physNet</span><span class="o">.</span><span class="n">createPin</span><span class="p">(</span><span class="n">portInst</span><span class="o">.</span><span class="n">isOutput</span><span class="p">(),</span><span class="n">siteWires</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">siteWires</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">siteInst</span><span class="p">)</span>
</code></pre></div></div>

<p>One observation to make here is that we have assumed all <strong>EDIFNet</strong>s are inter-Site. This will not be the case if we do packing, in which case the use of <code class="highlighter-rouge">getSitePinFromPortInst()</code> would be incorrect. Therefore, if packing is done, we need to have a further check which skips any intra-<em>Site</em> <strong>EDIFNet</strong>s.</p>

<h2 id="step-5-routing-site-wires">Step 5: Routing Site Wires</h2>

<p>Once we’ve set up our <strong>Net</strong>s to represent inter-<em>Site</em> connectivity, we need to route the <em>Site</em> wires to implement the require intra-<em>Site</em> connectivity. As discussed earlier, this effectively means turning on appropriate <strong>SitePIP</strong>s in our <strong>Design</strong>’s <strong>SiteInst</strong>s. The code and its breakdown is given below. Note that we have hardcoded support for <em>BUFGCTRL</em>, <em>FDRE</em> and <em>LUT</em> here - while we initially did this using a generic technology-independent algorithm, the complexity of the process made it far too non-intuitive for the purposes of this demo. Also note that while <strong>Design</strong> has a routine <code class="highlighter-rouge">routeSites()</code> that should do all the processes below automatically, we found that this routine alone was not sufficient in routing the <em>Site</em> wires - hence, the <code class="highlighter-rouge">routeSitePIPs()</code> routine is needed.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">routeSitePIPs</span><span class="p">(</span><span class="n">design</span><span class="p">):</span>
    <span class="n">netlist</span> <span class="o">=</span> <span class="n">design</span><span class="o">.</span><span class="n">getNetlist</span><span class="p">()</span>
    <span class="n">topCell</span> <span class="o">=</span> <span class="n">netlist</span><span class="o">.</span><span class="n">getTopCell</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">edifNet</span> <span class="ow">in</span> <span class="n">topCell</span><span class="o">.</span><span class="n">getNets</span><span class="p">()</span><span class="o">.</span><span class="n">toArray</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">checkIfTopPort</span><span class="p">(</span><span class="n">topCell</span><span class="p">,</span><span class="n">edifNet</span><span class="p">):</span> <span class="k">continue</span> 
        <span class="k">if</span> <span class="n">edifNet</span> <span class="o">==</span> <span class="n">EDIFTools</span><span class="o">.</span><span class="n">getStaticNet</span><span class="p">(</span><span class="n">NetType</span><span class="o">.</span><span class="n">GND</span><span class="p">,</span> <span class="n">topCell</span><span class="p">,</span> <span class="n">netlist</span><span class="p">):</span> <span class="k">continue</span> 
        <span class="k">for</span> <span class="n">portInst</span> <span class="ow">in</span> <span class="n">edifNet</span><span class="o">.</span><span class="n">getPortInsts</span><span class="p">()</span><span class="o">.</span><span class="n">toArray</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">portInst</span><span class="o">.</span><span class="n">isPrimitiveStaticSource</span><span class="p">():</span> <span class="k">continue</span>
            <span class="n">portCell</span> <span class="o">=</span> <span class="n">portInst</span><span class="o">.</span><span class="n">getCellInst</span><span class="p">()</span>
            <span class="n">physCell</span> <span class="o">=</span> <span class="n">design</span><span class="o">.</span><span class="n">getCell</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">portCell</span><span class="p">))</span>
            <span class="n">siteInst</span> <span class="o">=</span> <span class="n">physCell</span><span class="o">.</span><span class="n">getSiteInst</span><span class="p">()</span>
            <span class="k">if</span> <span class="s">"BUFGCTRL"</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">physCell</span><span class="o">.</span><span class="n">getType</span><span class="p">()):</span>
                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span><span class="p">(</span><span class="s">"CE0"</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">portInst</span><span class="o">.</span><span class="n">getName</span><span class="p">())))</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span><span class="p">(</span><span class="s">"S0"</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">portInst</span><span class="o">.</span><span class="n">getName</span><span class="p">()))):</span> <span class="k">continue</span>
                <span class="n">siteWires</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">physCell</span><span class="o">.</span><span class="n">getSitePinFromPortInst</span><span class="p">(</span><span class="n">portInst</span><span class="p">,</span><span class="n">siteWires</span><span class="p">)</span>
                <span class="n">bel</span> <span class="o">=</span> <span class="n">siteWires</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">"_"</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> 
                <span class="n">belpin</span> <span class="o">=</span> <span class="s">""</span>
                <span class="k">for</span> <span class="n">bp</span> <span class="ow">in</span> <span class="n">siteInst</span><span class="o">.</span><span class="n">getSite</span><span class="p">()</span><span class="o">.</span><span class="n">getBELPins</span><span class="p">(</span><span class="n">siteWires</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">():</span>
                    <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">bel</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">bp</span><span class="p">):</span>
                        <span class="n">belpin</span> <span class="o">=</span> <span class="n">bp</span>
                        <span class="k">break</span>
                <span class="n">sitepip</span> <span class="o">=</span> <span class="n">siteInst</span><span class="o">.</span><span class="n">getSitePIP</span><span class="p">(</span><span class="n">belpin</span><span class="p">)</span>
                <span class="n">siteInst</span><span class="o">.</span><span class="n">addSitePIP</span><span class="p">(</span><span class="n">sitepip</span><span class="p">)</span>
                <span class="n">siteInst</span><span class="o">.</span><span class="n">routeSite</span><span class="p">()</span>
            <span class="k">elif</span> <span class="s">"FDRE"</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">physCell</span><span class="o">.</span><span class="n">getType</span><span class="p">()):</span>
                <span class="k">if</span> <span class="p">(</span><span class="s">"CE"</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">portInst</span><span class="o">.</span><span class="n">getName</span><span class="p">())):</span>
                    <span class="n">belpin</span> <span class="o">=</span> <span class="n">siteInst</span><span class="o">.</span><span class="n">getSite</span><span class="p">()</span><span class="o">.</span><span class="n">getBEL</span><span class="p">(</span><span class="s">"CEUSEDMUX"</span><span class="p">)</span><span class="o">.</span><span class="n">getPin</span><span class="p">(</span><span class="s">"1"</span><span class="p">)</span>
                    <span class="n">sitepip</span> <span class="o">=</span> <span class="n">siteInst</span><span class="o">.</span><span class="n">getSitePIP</span><span class="p">(</span><span class="n">belpin</span><span class="p">)</span>
                    <span class="n">siteInst</span><span class="o">.</span><span class="n">addSitePIP</span><span class="p">(</span><span class="n">sitepip</span><span class="p">)</span>
                    <span class="n">siteInst</span><span class="o">.</span><span class="n">routeSite</span><span class="p">()</span>  
                <span class="k">elif</span> <span class="p">(</span><span class="s">"R"</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">portInst</span><span class="o">.</span><span class="n">getName</span><span class="p">())):</span>
                    <span class="n">belpin</span> <span class="o">=</span> <span class="n">siteInst</span><span class="o">.</span><span class="n">getSite</span><span class="p">()</span><span class="o">.</span><span class="n">getBEL</span><span class="p">(</span><span class="s">"SRUSEDMUX"</span><span class="p">)</span><span class="o">.</span><span class="n">getPin</span><span class="p">(</span><span class="s">"0"</span><span class="p">)</span>
                    <span class="n">sitepip</span> <span class="o">=</span> <span class="n">siteInst</span><span class="o">.</span><span class="n">getSitePIP</span><span class="p">(</span><span class="n">belpin</span><span class="p">)</span>
                    <span class="n">siteInst</span><span class="o">.</span><span class="n">addSitePIP</span><span class="p">(</span><span class="n">sitepip</span><span class="p">)</span>
                    <span class="n">siteInst</span><span class="o">.</span><span class="n">routeSite</span><span class="p">()</span>  
                <span class="k">elif</span> <span class="p">(</span><span class="s">"C"</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">portInst</span><span class="o">.</span><span class="n">getName</span><span class="p">())):</span>
                    <span class="n">belpin</span> <span class="o">=</span> <span class="n">siteInst</span><span class="o">.</span><span class="n">getSite</span><span class="p">()</span><span class="o">.</span><span class="n">getBEL</span><span class="p">(</span><span class="s">"CLKINV"</span><span class="p">)</span><span class="o">.</span><span class="n">getPin</span><span class="p">(</span><span class="s">"CLK"</span><span class="p">)</span>
                    <span class="n">sitepip</span> <span class="o">=</span> <span class="n">siteInst</span><span class="o">.</span><span class="n">getSitePIP</span><span class="p">(</span><span class="n">belpin</span><span class="p">)</span>
                    <span class="n">siteInst</span><span class="o">.</span><span class="n">addSitePIP</span><span class="p">(</span><span class="n">sitepip</span><span class="p">)</span>
                    <span class="n">siteInst</span><span class="o">.</span><span class="n">routeSite</span><span class="p">()</span>
                <span class="k">elif</span>  <span class="p">(</span><span class="s">"Q"</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">portInst</span><span class="o">.</span><span class="n">getName</span><span class="p">())):</span>
                    <span class="n">siteWires</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="n">physCell</span><span class="o">.</span><span class="n">getSitePinFromPortInst</span><span class="p">(</span><span class="n">portInst</span><span class="p">,</span><span class="n">siteWires</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">siteWires</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">belpin</span> <span class="o">=</span> <span class="s">""</span>
                        <span class="k">for</span> <span class="n">bp</span> <span class="ow">in</span> <span class="n">siteInst</span><span class="o">.</span><span class="n">getSite</span><span class="p">()</span><span class="o">.</span><span class="n">getBELPins</span><span class="p">(</span><span class="n">siteWires</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">():</span>
                            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">siteInst</span><span class="o">.</span><span class="n">getSite</span><span class="p">()</span><span class="o">.</span><span class="n">getBELPins</span><span class="p">(</span><span class="n">siteWires</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">"."</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">bp</span><span class="p">):</span>
                                <span class="n">belpin</span> <span class="o">=</span> <span class="n">bp</span>
                                <span class="k">break</span>
                        <span class="n">sitepip</span> <span class="o">=</span> <span class="n">siteInst</span><span class="o">.</span><span class="n">getSitePIP</span><span class="p">(</span><span class="n">belpin</span><span class="p">)</span>
                        <span class="n">siteInst</span><span class="o">.</span><span class="n">addSitePIP</span><span class="p">(</span><span class="n">sitepip</span><span class="p">)</span>
                        <span class="n">siteInst</span><span class="o">.</span><span class="n">routeSite</span><span class="p">()</span>                
                <span class="k">elif</span>  <span class="p">(</span><span class="s">"D"</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">portInst</span><span class="o">.</span><span class="n">getName</span><span class="p">())):</span>
                    <span class="n">siteWires</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="n">physCell</span><span class="o">.</span><span class="n">getSitePinFromPortInst</span><span class="p">(</span><span class="n">portInst</span><span class="p">,</span><span class="n">siteWires</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">siteWires</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">bel</span> <span class="o">=</span> <span class="n">siteWires</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">"_"</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> 
                        <span class="n">belpin</span> <span class="o">=</span> <span class="s">""</span>
                        <span class="k">for</span> <span class="n">bp</span> <span class="ow">in</span> <span class="n">siteInst</span><span class="o">.</span><span class="n">getSite</span><span class="p">()</span><span class="o">.</span><span class="n">getBELPins</span><span class="p">(</span><span class="n">siteWires</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">():</span>
                            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">bel</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">bp</span><span class="p">):</span>
                                <span class="n">belpin</span> <span class="o">=</span> <span class="n">bp</span>
                                <span class="k">break</span>
                        <span class="n">sitepip</span> <span class="o">=</span> <span class="n">siteInst</span><span class="o">.</span><span class="n">getSitePIP</span><span class="p">(</span><span class="n">belpin</span><span class="p">)</span>
                        <span class="n">siteInst</span><span class="o">.</span><span class="n">addSitePIP</span><span class="p">(</span><span class="n">sitepip</span><span class="p">)</span>
                        <span class="n">siteInst</span><span class="o">.</span><span class="n">routeSite</span><span class="p">()</span>
            <span class="k">elif</span> <span class="s">"LUT"</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">physCell</span><span class="o">.</span><span class="n">getType</span><span class="p">()):</span>
                <span class="n">siteWires</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">physCell</span><span class="o">.</span><span class="n">getSitePinFromPortInst</span><span class="p">(</span><span class="n">portInst</span><span class="p">,</span><span class="n">siteWires</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">siteWires</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">portInst</span><span class="o">.</span><span class="n">isOutput</span><span class="p">():</span>
                    <span class="k">if</span> <span class="p">(</span><span class="s">"IOB"</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">siteInst</span><span class="o">.</span><span class="n">getSite</span><span class="p">()</span><span class="o">.</span><span class="n">getSiteTypeEnum</span><span class="p">())):</span> <span class="k">continue</span>
                    <span class="n">belpin</span> <span class="o">=</span> <span class="s">""</span>
                    <span class="k">for</span> <span class="n">bp</span> <span class="ow">in</span> <span class="n">siteInst</span><span class="o">.</span><span class="n">getSite</span><span class="p">()</span><span class="o">.</span><span class="n">getBELPins</span><span class="p">(</span><span class="n">siteWires</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">():</span>
                        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">siteInst</span><span class="o">.</span><span class="n">getSite</span><span class="p">()</span><span class="o">.</span><span class="n">getBELPins</span><span class="p">(</span><span class="n">siteWires</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">"."</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">bp</span><span class="p">):</span>
                            <span class="n">belpin</span> <span class="o">=</span> <span class="n">bp</span>
                            <span class="k">break</span>
                    <span class="n">sitepip</span> <span class="o">=</span> <span class="n">siteInst</span><span class="o">.</span><span class="n">getSitePIP</span><span class="p">(</span><span class="n">belpin</span><span class="p">)</span>
                    <span class="n">siteInst</span><span class="o">.</span><span class="n">addSitePIP</span><span class="p">(</span><span class="n">sitepip</span><span class="p">)</span>
                    <span class="n">siteInst</span><span class="o">.</span><span class="n">routeSite</span><span class="p">()</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">routeSitePIPs()</code> routine takes the <strong>Design</strong> as its input and modifies it directly.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">routeSitePIPs</span><span class="p">(</span><span class="n">design</span><span class="p">):</span>
</code></pre></div></div>

<p>We begin by looping over all <strong>EDIFNet</strong>s in the design, as long as they do not correspond to the <em>PAD</em>-<em>I/O Buffer</em> connectivity and the <em>GND</em> connections - we still have to handle <em>VCC</em> connections since, unlike <em>GND</em>, <em>VCC</em> connections are not routed internally in a <em>Site</em>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">netlist</span> <span class="o">=</span> <span class="n">design</span><span class="o">.</span><span class="n">getNetlist</span><span class="p">()</span>
    <span class="n">topCell</span> <span class="o">=</span> <span class="n">netlist</span><span class="o">.</span><span class="n">getTopCell</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">edifNet</span> <span class="ow">in</span> <span class="n">topCell</span><span class="o">.</span><span class="n">getNets</span><span class="p">()</span><span class="o">.</span><span class="n">toArray</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">checkIfTopPort</span><span class="p">(</span><span class="n">topCell</span><span class="p">,</span><span class="n">edifNet</span><span class="p">):</span> <span class="k">continue</span> 
        <span class="k">if</span> <span class="n">edifNet</span> <span class="o">==</span> <span class="n">EDIFTools</span><span class="o">.</span><span class="n">getStaticNet</span><span class="p">(</span><span class="n">NetType</span><span class="o">.</span><span class="n">GND</span><span class="p">,</span> <span class="n">topCell</span><span class="p">,</span> <span class="n">netlist</span><span class="p">):</span> <span class="k">continue</span> 
</code></pre></div></div>
<p>For each <strong>EDIFNet</strong> in <code class="highlighter-rouge">topCell</code>, we loop over every <strong>EDIFPortInst</strong> as long as it is not a source for <em>VCC</em>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">for</span> <span class="n">portInst</span> <span class="ow">in</span> <span class="n">edifNet</span><span class="o">.</span><span class="n">getPortInsts</span><span class="p">()</span><span class="o">.</span><span class="n">toArray</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">portInst</span><span class="o">.</span><span class="n">isPrimitiveStaticSource</span><span class="p">():</span> <span class="k">continue</span>
</code></pre></div></div>

<p>Next, we use an <strong>EDIFPortInst</strong> to get the corresponding <strong>EDIFCellInst</strong>, <strong>Cell</strong> and <strong>SiteInst</strong>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="n">portCell</span> <span class="o">=</span> <span class="n">portInst</span><span class="o">.</span><span class="n">getCellInst</span><span class="p">()</span>
            <span class="n">physCell</span> <span class="o">=</span> <span class="n">design</span><span class="o">.</span><span class="n">getCell</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">portCell</span><span class="p">))</span>
            <span class="n">siteInst</span> <span class="o">=</span> <span class="n">physCell</span><span class="o">.</span><span class="n">getSiteInst</span><span class="p">()</span>
</code></pre></div></div>

<p>For <code class="highlighter-rouge">BUFGCTRL</code>, we need to set the <strong>SitePIP</strong>s for the <code class="highlighter-rouge">CE0</code> and <code class="highlighter-rouge">S0</code> pins so that these <em>BEL</em> pins can be connected <em>Site</em> pins, which in turn can then be connected to a <em>VCC</em> source external to the <em>Site</em>. To turn on a <strong>SitePIP</strong>, we need to first select it from its <strong>SiteInst</strong>, then call the <code class="highlighter-rouge">addSitePIP()</code> routine from <strong>SiteInst</strong>, and finally call the <code class="highlighter-rouge">routeSite()</code> routine again from <strong>SiteInst</strong>. To find the <strong>SitePIP</strong> of interest, we use the earlier trick of working with wires within the <em>Site</em> i.e. the <code class="highlighter-rouge">getSitePinFromPortInst()</code> routine in <strong>Cell</strong>. In the previous Step, we took the last value of <code class="highlighter-rouge">siteWires</code> since it corresponded to the <strong>SitePin</strong>’s name. This time, we will use both the first and last values. We beging by using the first value since it is the output wire of the <em>Routing BEL</em> that drives that <strong>BELPin</strong>. This wire is formatted as “&lt;<em>Routing BEL Name</em>&gt;_OUT”. By splitting the string at “_”, we can find the name of this <em>Routing BEL</em>. Next, we take the last value of <code class="highlighter-rouge">siteWires</code> - since the size of <code class="highlighter-rouge">siteWires</code> will always be 2 for <code class="highlighter-rouge">BUFGCTRLs</code>, we simply do <code class="highlighter-rouge">siteWires[1]</code>. We then call <code class="highlighter-rouge">getBELPins()</code> from <strong>Site</strong> using this wire name (which is also the <strong>SitePin</strong> name) and get a list of all <strong>BELPin</strong>s connected to it. We are now one step away from getting the <strong>SitePIP</strong> of interest. If we can find the correct <strong>BELPin</strong>, we can call the <code class="highlighter-rouge">getSitePIP()</code> routine from the <strong>SiteInst</strong> (i.e. which input of the MUX do we want to select?). Knowing the name of the <em>Routing BEL</em> allows us to determine which pins in the list are its inputs. Since we are dealing with <code class="highlighter-rouge">BUFGCTRL</code>, there we be only two such pins. From these, we select the non-inverting input by leveraging the “_B” suffix of the inverting input. Once we have the <strong>BELPin</strong> name, we get the corresponding <strong>SitePIP</strong> through a <code class="highlighter-rouge">getSitePIP()</code> call, followed by a <code class="highlighter-rouge">addSitePIP()</code> call on this <strong>SitePIP</strong>, and then finally a <code class="highlighter-rouge">routeSite()</code> call for the <strong>SiteInst</strong>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="k">if</span> <span class="s">"BUFGCTRL"</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">physCell</span><span class="o">.</span><span class="n">getType</span><span class="p">()):</span>
                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span><span class="p">(</span><span class="s">"CE0"</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">portInst</span><span class="o">.</span><span class="n">getName</span><span class="p">())))</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span><span class="p">(</span><span class="s">"S0"</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">portInst</span><span class="o">.</span><span class="n">getName</span><span class="p">()))):</span> <span class="k">continue</span>
                <span class="n">siteWires</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">physCell</span><span class="o">.</span><span class="n">getSitePinFromPortInst</span><span class="p">(</span><span class="n">portInst</span><span class="p">,</span><span class="n">siteWires</span><span class="p">)</span>
                <span class="n">bel</span> <span class="o">=</span> <span class="n">siteWires</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">"_"</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> 
                <span class="n">belpin</span> <span class="o">=</span> <span class="s">""</span>
                <span class="k">for</span> <span class="n">bp</span> <span class="ow">in</span> <span class="n">siteInst</span><span class="o">.</span><span class="n">getSite</span><span class="p">()</span><span class="o">.</span><span class="n">getBELPins</span><span class="p">(</span><span class="n">siteWires</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">():</span>
                    <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">bel</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span><span class="p">(</span><span class="s">"_B"</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">bp</span><span class="p">))):</span>
                        <span class="n">belpin</span> <span class="o">=</span> <span class="n">bp</span>
                        <span class="k">break</span>
                <span class="n">sitepip</span> <span class="o">=</span> <span class="n">siteInst</span><span class="o">.</span><span class="n">getSitePIP</span><span class="p">(</span><span class="n">belpin</span><span class="p">)</span>
                <span class="n">siteInst</span><span class="o">.</span><span class="n">addSitePIP</span><span class="p">(</span><span class="n">sitepip</span><span class="p">)</span>
                <span class="n">siteInst</span><span class="o">.</span><span class="n">routeSite</span><span class="p">()</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">FDRE</code> (i.e. D Flip Flops) are substantially more complicated than <code class="highlighter-rouge">BUFGCTRL</code>s since we not only need to deal with both data and control pins, but we also have to deal with both input and output pins (<code class="highlighter-rouge">BUGCTRL</code> only required dealing with input pins), and we also have to deal with the different types of <code class="highlighter-rouge">FDRE</code> connectivity in a logic block (4 of the 8 <code class="highlighter-rouge">FDRE</code>s in a logic block have a <em>Routing BEL</em> on their data input, and the remaining 4 have it on their data output). As a result, we will have a separate algorithm for each <strong>BELPin</strong> in the <code class="highlighter-rouge">FDRE</code> <strong>BEL</strong>.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="k">elif</span> <span class="s">"FDRE"</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">physCell</span><span class="o">.</span><span class="n">getType</span><span class="p">()):</span>
</code></pre></div></div>
<p>Let’s start with the <code class="highlighter-rouge">CE</code> (chip enable) pin. All <code class="highlighter-rouge">FDRE</code> chip enable pins are connected together, which means enabling one <code class="highlighter-rouge">FDRE</code> will enable all of them. The <em>Routing BEL</em> named <code class="highlighter-rouge">CEUSEDMUX</code> is used to select the state of <code class="highlighter-rouge">CE</code> pins. <code class="highlighter-rouge">CEUSEDMUX</code> has two inputs - one for hardwiring the connection to logic 1 and the other for providing an external (to the <em>Site</em>) signal to dynamically modify the <code class="highlighter-rouge">CE</code> value. In our case, since our <code class="highlighter-rouge">FDREs</code> are always on, we will select the hardwired logic 1. This would correspond to the <strong>BELPin</strong> name <code class="highlighter-rouge">1</code> in the <strong>BEL</strong> <code class="highlighter-rouge">CEUSEDMUX</code>. Once we have the <strong>BELPin</strong>, we can then call <code class="highlighter-rouge">addSitePIP()</code> and <code class="highlighter-rouge">routeSite()</code> to turn the <strong>SitePIP</strong> on.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                <span class="k">if</span> <span class="p">(</span><span class="s">"CE"</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">portInst</span><span class="o">.</span><span class="n">getName</span><span class="p">())):</span>
                    <span class="n">belpin</span> <span class="o">=</span> <span class="n">siteInst</span><span class="o">.</span><span class="n">getSite</span><span class="p">()</span><span class="o">.</span><span class="n">getBEL</span><span class="p">(</span><span class="s">"CEUSEDMUX"</span><span class="p">)</span><span class="o">.</span><span class="n">getPin</span><span class="p">(</span><span class="s">"1"</span><span class="p">)</span>
                    <span class="n">sitepip</span> <span class="o">=</span> <span class="n">siteInst</span><span class="o">.</span><span class="n">getSitePIP</span><span class="p">(</span><span class="n">belpin</span><span class="p">)</span>
                    <span class="n">siteInst</span><span class="o">.</span><span class="n">addSitePIP</span><span class="p">(</span><span class="n">sitepip</span><span class="p">)</span>
                    <span class="n">siteInst</span><span class="o">.</span><span class="n">routeSite</span><span class="p">()</span>  
</code></pre></div></div>

<p><code class="highlighter-rouge">R</code>, i.e. the reset pin, follows the same approach as <code class="highlighter-rouge">CE</code>, except that we will tie it to <em>GND</em>, i.e. logic 0. The <strong>BEL</strong> here is <code class="highlighter-rouge">SRUSEDMUX</code> and the <strong>BELPin</strong> is <code class="highlighter-rouge">0</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                <span class="k">elif</span> <span class="p">(</span><span class="s">"R"</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">portInst</span><span class="o">.</span><span class="n">getName</span><span class="p">())):</span>
                    <span class="n">belpin</span> <span class="o">=</span> <span class="n">siteInst</span><span class="o">.</span><span class="n">getSite</span><span class="p">()</span><span class="o">.</span><span class="n">getBEL</span><span class="p">(</span><span class="s">"SRUSEDMUX"</span><span class="p">)</span><span class="o">.</span><span class="n">getPin</span><span class="p">(</span><span class="s">"0"</span><span class="p">)</span>
                    <span class="n">sitepip</span> <span class="o">=</span> <span class="n">siteInst</span><span class="o">.</span><span class="n">getSitePIP</span><span class="p">(</span><span class="n">belpin</span><span class="p">)</span>
                    <span class="n">siteInst</span><span class="o">.</span><span class="n">addSitePIP</span><span class="p">(</span><span class="n">sitepip</span><span class="p">)</span>
                    <span class="n">siteInst</span><span class="o">.</span><span class="n">routeSite</span><span class="p">()</span>  
</code></pre></div></div>

<p>The (routing) <strong>BEL</strong> on the clock input selects between providing the clock as is, or inverting it. Since all the clocks in our design are positive edge triggered, we can hardcode this as well. The <strong>BEL</strong> here is called <code class="highlighter-rouge">CLKINV</code>, and the <strong>BELPin</strong> for the non-inverting input is <code class="highlighter-rouge">CLK</code>. Note that all <code class="highlighter-rouge">FDREs</code> share the same clock line.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                <span class="k">elif</span> <span class="p">(</span><span class="s">"C"</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">portInst</span><span class="o">.</span><span class="n">getName</span><span class="p">())):</span>
                    <span class="n">belpin</span> <span class="o">=</span> <span class="n">siteInst</span><span class="o">.</span><span class="n">getSite</span><span class="p">()</span><span class="o">.</span><span class="n">getBEL</span><span class="p">(</span><span class="s">"CLKINV"</span><span class="p">)</span><span class="o">.</span><span class="n">getPin</span><span class="p">(</span><span class="s">"CLK"</span><span class="p">)</span>
                    <span class="n">sitepip</span> <span class="o">=</span> <span class="n">siteInst</span><span class="o">.</span><span class="n">getSitePIP</span><span class="p">(</span><span class="n">belpin</span><span class="p">)</span>
                    <span class="n">siteInst</span><span class="o">.</span><span class="n">addSitePIP</span><span class="p">(</span><span class="n">sitepip</span><span class="p">)</span>
                    <span class="n">siteInst</span><span class="o">.</span><span class="n">routeSite</span><span class="p">()</span>
</code></pre></div></div>
<p>Now we get to the data pins. Let’s start with <code class="highlighter-rouge">Q</code> i.e. the data output pin. This is similar to the control input pins for <code class="highlighter-rouge">BUFGCTRL</code>, except that now the pin may be connected to the input of a  <em>Routing BEL</em> instead of its output. If there is no <em>Routing BEL</em> on the <code class="highlighter-rouge">Q</code> pin, we don’t need to do anything. This is relatively simply check to make, leveraging yet again the highly useful <code class="highlighter-rouge">getSitePinFromPortInst()</code> routing. If no <em>Routing BEL</em> is present on the <code class="highlighter-rouge">Q</code> pin, the length of the <code class="highlighter-rouge">siteWires</code> list will be 1 and we can move on to the next loop iteration.</p>

<p>If the size of <code class="highlighter-rouge">siteWires</code> is greater than 1, we need to find the input pin of the <em>Routing BEL</em> to which <code class="highlighter-rouge">Q</code> is connected. Note that the size of <code class="highlighter-rouge">siteWires</code> will be a maximum of 2 since there can only be a maximum of 1 <em>Routing BEL</em> on the output path. The algorithm here is similar to <code class="highlighter-rouge">BUFGCTRL</code> - we used <code class="highlighter-rouge">siteWires[1]</code> to get the name of the <em>Routing BEL</em>, and then scan all <strong>BELPin</strong>s connected to <code class="highlighter-rouge">Q</code> (using <code class="highlighter-rouge">getBELPins(siteWires[0])</code>) to find the <strong>BELPin</strong> belong to this <em>Routing BEL</em>. Note that a string split here is not necessary to get the <em>Routing BEL</em>’s name - it is also possible to get the <em>Routing BEL</em>’s name by get the <strong>BELPin</strong> on the wire name stored in <code class="highlighter-rouge">siteWires[1]</code>, and then using a series of routines to get the name of the corresponding <strong>BEL</strong>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                <span class="k">elif</span>  <span class="p">(</span><span class="s">"Q"</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">portInst</span><span class="o">.</span><span class="n">getName</span><span class="p">())):</span>
                    <span class="n">siteWires</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="n">physCell</span><span class="o">.</span><span class="n">getSitePinFromPortInst</span><span class="p">(</span><span class="n">portInst</span><span class="p">,</span><span class="n">siteWires</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">siteWires</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">belpin</span> <span class="o">=</span> <span class="s">""</span>
                        <span class="k">for</span> <span class="n">bp</span> <span class="ow">in</span> <span class="n">siteInst</span><span class="o">.</span><span class="n">getSite</span><span class="p">()</span><span class="o">.</span><span class="n">getBELPins</span><span class="p">(</span><span class="n">siteWires</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">():</span>
                            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">siteInst</span><span class="o">.</span><span class="n">getSite</span><span class="p">()</span><span class="o">.</span><span class="n">getBELPins</span><span class="p">(</span><span class="n">siteWires</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">"."</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">bp</span><span class="p">):</span>
                                <span class="n">belpin</span> <span class="o">=</span> <span class="n">bp</span>
                                <span class="k">break</span>
                        <span class="n">sitepip</span> <span class="o">=</span> <span class="n">siteInst</span><span class="o">.</span><span class="n">getSitePIP</span><span class="p">(</span><span class="n">belpin</span><span class="p">)</span>
                        <span class="n">siteInst</span><span class="o">.</span><span class="n">addSitePIP</span><span class="p">(</span><span class="n">sitepip</span><span class="p">)</span>
                        <span class="n">siteInst</span><span class="o">.</span><span class="n">routeSite</span><span class="p">()</span>
</code></pre></div></div>
<p>The last pin for <code class="highlighter-rouge">FDRE</code> is the data input pin <code class="highlighter-rouge">D</code>. If there is a <em>Routing BEL</em> present at the <code class="highlighter-rouge">FDRE</code> data input (determined by looking at the <code class="highlighter-rouge">siteWires</code> list size), we reuse the <code class="highlighter-rouge">BUFGCTRL</code> algorithm to turn on the appropriate <strong>SitePIP</strong>. The only difference here is that there will only be one input pin of the <em>Routing BEL</em> with the same name as the <strong>SitePin</strong> since the option for inverting the data input is not available.</p>

<p>As discussed earlier, the assumption here is that there is no intra-<em>Site</em> <strong>EDIFNet</strong>s. If such a connectivity did exist, we likely would not be able to use <code class="highlighter-rouge">getSitePinFromPortInst()</code> in the exact way that we are doing currently. Additional code would be required to find the one or more <strong>SitePIP</strong>s that will route the intra-<em>Site</em> <strong>EDIFNet</strong>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                <span class="k">elif</span>  <span class="p">(</span><span class="s">"D"</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">portInst</span><span class="o">.</span><span class="n">getName</span><span class="p">())):</span>
                    <span class="n">siteWires</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="n">physCell</span><span class="o">.</span><span class="n">getSitePinFromPortInst</span><span class="p">(</span><span class="n">portInst</span><span class="p">,</span><span class="n">siteWires</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">siteWires</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">bel</span> <span class="o">=</span> <span class="n">siteWires</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">"_"</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> 
                        <span class="n">belpin</span> <span class="o">=</span> <span class="s">""</span>
                        <span class="k">for</span> <span class="n">bp</span> <span class="ow">in</span> <span class="n">siteInst</span><span class="o">.</span><span class="n">getSite</span><span class="p">()</span><span class="o">.</span><span class="n">getBELPins</span><span class="p">(</span><span class="n">siteWires</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">():</span>
                            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">bel</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">bp</span><span class="p">):</span>
                                <span class="n">belpin</span> <span class="o">=</span> <span class="n">bp</span>
                                <span class="k">break</span>
                        <span class="n">sitepip</span> <span class="o">=</span> <span class="n">siteInst</span><span class="o">.</span><span class="n">getSitePIP</span><span class="p">(</span><span class="n">belpin</span><span class="p">)</span>
                        <span class="n">siteInst</span><span class="o">.</span><span class="n">addSitePIP</span><span class="p">(</span><span class="n">sitepip</span><span class="p">)</span>
                        <span class="n">siteInst</span><span class="o">.</span><span class="n">routeSite</span><span class="p">()</span>
</code></pre></div></div>
<p>Finally, we get to the last type of technology i.e. <code class="highlighter-rouge">LUT</code> (Look Up Table). The algorithm here is similar to <code class="highlighter-rouge">Q</code> for <code class="highlighter-rouge">FDRE</code>. Note that the <code class="highlighter-rouge">LUT</code> inputs are always directly connected to <em>Site</em> pins, while the output is always connected to a <em>Routing BEL</em>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="k">elif</span> <span class="s">"LUT"</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">physCell</span><span class="o">.</span><span class="n">getType</span><span class="p">()):</span>
                <span class="n">siteWires</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">physCell</span><span class="o">.</span><span class="n">getSitePinFromPortInst</span><span class="p">(</span><span class="n">portInst</span><span class="p">,</span><span class="n">siteWires</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">siteWires</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">portInst</span><span class="o">.</span><span class="n">isOutput</span><span class="p">():</span>
                    <span class="n">belpin</span> <span class="o">=</span> <span class="s">""</span>
                    <span class="k">for</span> <span class="n">bp</span> <span class="ow">in</span> <span class="n">siteInst</span><span class="o">.</span><span class="n">getSite</span><span class="p">()</span><span class="o">.</span><span class="n">getBELPins</span><span class="p">(</span><span class="n">siteWires</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">():</span>
                        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">siteInst</span><span class="o">.</span><span class="n">getSite</span><span class="p">()</span><span class="o">.</span><span class="n">getBELPins</span><span class="p">(</span><span class="n">siteWires</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">"."</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">bp</span><span class="p">):</span>
                            <span class="n">belpin</span> <span class="o">=</span> <span class="n">bp</span>
                            <span class="k">break</span>
                    <span class="n">sitepip</span> <span class="o">=</span> <span class="n">siteInst</span><span class="o">.</span><span class="n">getSitePIP</span><span class="p">(</span><span class="n">belpin</span><span class="p">)</span>
                    <span class="n">siteInst</span><span class="o">.</span><span class="n">addSitePIP</span><span class="p">(</span><span class="n">sitepip</span><span class="p">)</span>
                    <span class="n">siteInst</span><span class="o">.</span><span class="n">routeSite</span><span class="p">()</span>
</code></pre></div></div>

<h2 id="step-6-route-clocks">Step 6: Route Clocks</h2>
<p>After finishing the intra-<em>Site</em> routing, we will now look at routing the <strong>Net</strong>s. As mentioned previously, routing a <strong>Net</strong> is effectively adding to it a list of <strong>PIP</strong>s that must be set. Routing algorithms are quite complex and it is difficult to write a trivial implementation. Even if we ignore timing requirements, the sheer size of the chip’s routing fabric (and Arty is supposed to be a low end board) means doing naive breadth-first or depth-first traversals can take a very long time to complete. Moreover, as we will see later on, there are a number of constraints to take into account as well. For example, clock based <strong>Net</strong>s are constrained to pass through horizontal clock buffers before they can drive logic, even though there is not <strong>Cell</strong> for a horizontal clock buffer in our design.</p>

<p>Luckily, RapidWright does provide a <strong>Router</strong> class for doing the routing. The source code for the routing algorithm is given <a href="https://github.com/Xilinx/RapidWright/blob/master/src/com/xilinx/rapidwright/router/Router.java">here</a>.</p>

<p>Unluckily, the routing algorithm is for UltraScale+ FPGAs.</p>

<p>Luckily, the algorithm is still applicable to 7-series FPGAs.</p>

<p>Unluckily, it will not handle clocking and only works for if the design is placed in a specific way (i.e. for certain seed values used for our random placer).</p>

<p>Luckily, we can split the routing process.</p>

<p>Since it is too complex to port the native RapidWright one, we will build a partial router that will route the clocks in our design, lock this routing, and then call the native RapidWright router for the remaining <strong>Net</strong>s. With regards to the seed value, we will put the RapidWright router call in a “try-catch” block and try different seed values still be find one that works.</p>

<p>Our algorithm for routing clocks will be based on the “Basic Routing” example given <a href="https://www.rapidwright.io/docs/FCCM19_Workshop.html">here</a>.</p>

<h3 id="some-more-imports">Some More Imports</h3>
<p>Let’s start by importing in some non-RapidWright Classes.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">java.util</span> <span class="kn">import</span> <span class="n">HashSet</span>
<span class="kn">from</span> <span class="nn">java.util</span> <span class="kn">import</span> <span class="n">List</span>
<span class="kn">import</span> <span class="nn">Queue</span>
<span class="kn">from</span> <span class="nn">Queue</span> <span class="kn">import</span> <span class="n">PriorityQueue</span>
</code></pre></div></div>

<h3 id="get-nets-driven-by-vertical-global-clock-buffers-bufgctrl-for-7-series-fpgas">Get Nets Driven By Vertical Global Clock Buffers (BUFGCTRL For 7-Series FPGAs)</h3>
<p>Next, we want to identify all the clock <strong>Net</strong>s in our design. To do this, we use a <code class="highlighter-rouge">get_main_clock_nets()</code> routine which finds all <strong>Net</strong>s who are being driven by a <code class="highlighter-rouge">BUFGCTRL</code>. Note that we can call <code class="highlighter-rouge">getSiteTypeEnum()</code> even though <code class="highlighter-rouge">BUFGCTRL</code> is technically a <em>BEL</em> - this is because the <em>Site</em> will also have <code class="highlighter-rouge">BUFGCTRL</code> in its name.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_main_clock_nets</span><span class="p">(</span><span class="n">design</span><span class="p">):</span>
    <span class="n">nets</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">net</span> <span class="ow">in</span> <span class="n">design</span><span class="o">.</span><span class="n">getNets</span><span class="p">():</span>
        <span class="n">pins</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">getPins</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">pin</span> <span class="ow">in</span> <span class="n">pins</span><span class="p">:</span>
            <span class="n">bel_type</span> <span class="o">=</span> <span class="n">pin</span><span class="o">.</span><span class="n">getSite</span><span class="p">()</span><span class="o">.</span><span class="n">getSiteTypeEnum</span><span class="p">()</span><span class="o">.</span><span class="n">toString</span><span class="p">()</span>
            <span class="k">if</span> <span class="s">"BUFGCTRL"</span> <span class="ow">in</span> <span class="n">bel_type</span> <span class="ow">and</span> <span class="n">pin</span><span class="o">.</span><span class="n">isOutPin</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">net</span> <span class="ow">in</span> <span class="n">nets</span><span class="p">:</span>
                    <span class="n">nets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">net</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nets</span>
</code></pre></div></div>

<h3 id="create-horizontal-clock-buffers-bufhce-for-7-series-fpgas">Create Horizontal Clock Buffers (BUFHCE For 7-Series FPGAs)</h3>
<p>The <strong>Net</strong>s we got in the previous step connect <code class="highlighter-rouge">BUFGCTRL</code> output pins to the clock input pins of logic blocks. Note that a <code class="highlighter-rouge">BUFGCTRL</code> is a vertical clock buffer, meaning that it can only drive wires that run vertically through the center of the FPGA chip. So how is it able to drive clock pins in a 2-D plane? The answer here is horizontal clock buffers - <code class="highlighter-rouge">BUFHCE</code> specifically for Xilinx 7-Series FPGAs. There are banks of multiple <code class="highlighter-rouge">BUFHCE</code>s located at different points of the vertical clock spline running through the middle of the 7-Series FPGA chip. Depending on which region of the chip our logic is located, we need to use an appropriate <code class="highlighter-rouge">BUFHCE</code> to ensure the clock signal can be routed to it. Note that use of <code class="highlighter-rouge">BUFHCE</code> is not reflected in the logical netlist. The is likely because, unlike <code class="highlighter-rouge">BUFGCTRL</code>, we do not know how many individual <code class="highlighter-rouge">BUFHCE</code> we will need and what logic will be driven by a given <code class="highlighter-rouge">BUFHCE</code>. Moreover, Vivado does not list <code class="highlighter-rouge">BUFHCE</code> as a component in the physical netlist - likely because <code class="highlighter-rouge">BUFHCE</code> are treated as “route-through” instead of actual netlist components.</p>

<p>To get a better understanding of the clock routing process, we will treat <code class="highlighter-rouge">BUFHCEs</code> as <strong>Cell</strong>s in our design and manually instantiate them. To create the required <code class="highlighter-rouge">BUFHCEs</code>, we need routines for: i) creating a cost function to find the appropriate <code class="highlighter-rouge">BUFHCE</code> <em>Site</em> for a given clock sink, ii) selecting a <code class="highlighter-rouge">BUFHCE</code> from the closest bank, iii) creating a <code class="highlighter-rouge">BUFHCE</code> <strong>Cell</strong> and updating <strong>Net</strong>s.</p>

<p>Let’s start with the cost function. In our case, we are going for the simple <a href="https://xlinux.nist.gov/dads/HTML/manhattanDistance.html">Manhattan distance</a> between two <strong>Site</strong>s. We use “Rpm” routines for this since they return the physical coordinates of a <strong>Site</strong> (as opposed to logical).</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">cost</span> <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">s1</span><span class="o">.</span><span class="n">getRpmX</span><span class="p">()</span> <span class="o">-</span> <span class="n">s2</span><span class="o">.</span><span class="n">getRpmX</span><span class="p">())</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">s1</span><span class="o">.</span><span class="n">getRpmY</span><span class="p">()</span> <span class="o">-</span> <span class="n">s2</span><span class="o">.</span><span class="n">getRpmY</span><span class="p">())</span>
</code></pre></div></div>

<p>Next, we write a <code class="highlighter-rouge">closestSite()</code> routine which returns the nearest <em>Site</em> to the <strong>Site</strong> <code class="highlighter-rouge">s1</code> from a list of possible <strong>Site</strong>s <code class="highlighter-rouge">possible_sites</code>. We simply evaluate the cost for each pair, and built a Priority Queue for the resulting tuple. Once we’ve iterated over all possibilities in <code class="highlighter-rouge">possible_sites</code>, we return the <strong>Site</strong> with the tuple with the lowest cost.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">closestSite</span> <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">possible_sites</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">PriorityQueue</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">s2</span> <span class="ow">in</span> <span class="n">possible_sites</span><span class="p">:</span>
        <span class="n">p</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="n">cost</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">),</span><span class="n">s2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
</code></pre></div></div>

<p>Finally, we get to our big routine <code class="highlighter-rouge">createBUFH</code>. This will be responsible for creating <code class="highlighter-rouge">BUFHCE</code> <strong>Cell</strong>s, updating existing <strong>Net</strong>s, and creating new <strong>Net</strong>s. The code and its breakdown is given below.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">createBUFHs</span><span class="p">(</span><span class="n">design</span><span class="p">):</span>
    <span class="n">topCell</span> <span class="o">=</span> <span class="n">design</span><span class="o">.</span><span class="n">getNetlist</span><span class="p">()</span><span class="o">.</span><span class="n">getTopCell</span><span class="p">()</span>
    <span class="n">bufhce_sites</span> <span class="o">=</span>  <span class="n">design</span><span class="o">.</span><span class="n">getDevice</span><span class="p">()</span><span class="o">.</span><span class="n">getAllCompatibleSites</span><span class="p">(</span><span class="n">SiteTypeEnum</span><span class="o">.</span><span class="n">BUFHCE</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">clk_net</span> <span class="ow">in</span> <span class="n">get_main_clock_nets</span><span class="p">(</span><span class="n">design</span><span class="p">):</span>
        <span class="n">pins</span> <span class="o">=</span> <span class="n">clk_net</span><span class="o">.</span><span class="n">getSinkPins</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pins</span><span class="p">)):</span>
            <span class="n">pin</span> <span class="o">=</span> <span class="n">pins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">pin_site</span> <span class="o">=</span> <span class="n">pin</span><span class="o">.</span><span class="n">getSite</span><span class="p">()</span>
            <span class="n">bufhce_site</span> <span class="o">=</span> <span class="n">closestSite</span><span class="p">(</span><span class="n">pin_site</span><span class="p">,</span><span class="n">bufhce_sites</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">exists</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">design</span><span class="o">.</span><span class="n">getCell</span><span class="p">(</span><span class="n">clk_net</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">+</span> <span class="s">"_bufhce_"</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">design</span><span class="o">.</span><span class="n">getCell</span><span class="p">(</span><span class="n">clk_net</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">+</span> <span class="s">"_bufhce_"</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">))</span><span class="o">.</span><span class="n">getSite</span><span class="p">())</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">bufhce_site</span><span class="p">):</span>
                        <span class="n">exists</span> <span class="o">=</span> <span class="n">j</span>

            <span class="k">if</span> <span class="n">exists</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">bufhce_site</span><span class="p">)</span> <span class="o">+</span><span class="s">"/BUFHCE"</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">design</span><span class="o">.</span><span class="n">createAndPlaceCell</span><span class="p">(</span><span class="n">clk_net</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">+</span> <span class="s">"_bufhce_"</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="n">Unisim</span><span class="o">.</span><span class="n">BUFHCE</span><span class="p">,</span><span class="n">loc</span><span class="p">)</span> 
                <span class="n">ret</span><span class="o">.</span><span class="n">connectStaticSourceToPin</span><span class="p">(</span><span class="n">NetType</span><span class="o">.</span><span class="n">VCC</span> <span class="p">,</span><span class="s">"CE"</span><span class="p">)</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">getSiteInst</span><span class="p">()</span><span class="o">.</span><span class="n">addSitePIP</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">getSiteInst</span><span class="p">()</span><span class="o">.</span><span class="n">getSitePIP</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">getSiteInst</span><span class="p">()</span><span class="o">.</span><span class="n">getBEL</span><span class="p">(</span><span class="s">"CEINV"</span><span class="p">)</span><span class="o">.</span><span class="n">getPin</span><span class="p">(</span><span class="s">"CE"</span><span class="p">)))</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">getSiteInst</span><span class="p">()</span><span class="o">.</span><span class="n">routeSite</span><span class="p">()</span>
                <span class="n">net</span> <span class="o">=</span> <span class="n">design</span><span class="o">.</span><span class="n">createNet</span><span class="p">(</span><span class="n">clk_net</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                <span class="n">clk_net</span><span class="o">.</span><span class="n">removePin</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span>
                <span class="n">clk_net</span><span class="o">.</span><span class="n">addPin</span><span class="p">(</span><span class="n">SitePinInst</span><span class="p">(</span><span class="s">"I"</span><span class="p">,</span><span class="n">ret</span><span class="o">.</span><span class="n">getSiteInst</span><span class="p">()))</span>
                <span class="n">net</span><span class="o">.</span><span class="n">addPin</span><span class="p">(</span><span class="n">SitePinInst</span><span class="p">(</span><span class="s">"O"</span><span class="p">,</span><span class="n">ret</span><span class="o">.</span><span class="n">getSiteInst</span><span class="p">()))</span>
                <span class="n">net</span><span class="o">.</span><span class="n">addPin</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span>
                <span class="n">topCell</span><span class="o">.</span><span class="n">getNet</span><span class="p">(</span><span class="n">clk_net</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="o">.</span><span class="n">createPortInst</span><span class="p">(</span><span class="s">"O"</span><span class="p">,</span><span class="n">ret</span><span class="p">)</span>
                <span class="n">topCell</span><span class="o">.</span><span class="n">getNet</span><span class="p">(</span><span class="n">clk_net</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="o">.</span><span class="n">addPortInst</span><span class="p">(</span><span class="n">topCell</span><span class="o">.</span><span class="n">getNet</span><span class="p">(</span><span class="n">clk_net</span><span class="o">.</span><span class="n">getName</span><span class="p">())</span><span class="o">.</span><span class="n">getPortInsts</span><span class="p">()</span><span class="o">.</span><span class="n">toArray</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">topCell</span><span class="o">.</span><span class="n">getNet</span><span class="p">(</span><span class="n">clk_net</span><span class="o">.</span><span class="n">getName</span><span class="p">())</span><span class="o">.</span><span class="n">createPortInst</span><span class="p">(</span><span class="s">"I"</span><span class="p">,</span><span class="n">ret</span><span class="p">)</span>
                <span class="n">topCell</span><span class="o">.</span><span class="n">getNet</span><span class="p">(</span><span class="n">clk_net</span><span class="o">.</span><span class="n">getName</span><span class="p">())</span><span class="o">.</span><span class="n">removePortInst</span><span class="p">(</span><span class="n">topCell</span><span class="o">.</span><span class="n">getNet</span><span class="p">(</span><span class="n">clk_net</span><span class="o">.</span><span class="n">getName</span><span class="p">())</span><span class="o">.</span><span class="n">getPortInsts</span><span class="p">()</span><span class="o">.</span><span class="n">toArray</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">net</span> <span class="o">=</span> <span class="n">design</span><span class="o">.</span><span class="n">getNet</span><span class="p">(</span><span class="n">clk_net</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">exists</span><span class="p">))</span>
                <span class="n">clk_net</span><span class="o">.</span><span class="n">removePin</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span>
                <span class="n">net</span><span class="o">.</span><span class="n">addPin</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span>
                <span class="n">topCell</span><span class="o">.</span><span class="n">getNet</span><span class="p">(</span><span class="n">clk_net</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">exists</span><span class="p">))</span><span class="o">.</span><span class="n">addPortInst</span><span class="p">(</span><span class="n">topCell</span><span class="o">.</span><span class="n">getNet</span><span class="p">(</span><span class="n">clk_net</span><span class="o">.</span><span class="n">getName</span><span class="p">())</span><span class="o">.</span><span class="n">getPortInsts</span><span class="p">()</span><span class="o">.</span><span class="n">toArray</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">topCell</span><span class="o">.</span><span class="n">getNet</span><span class="p">(</span><span class="n">clk_net</span><span class="o">.</span><span class="n">getName</span><span class="p">())</span><span class="o">.</span><span class="n">removePortInst</span><span class="p">(</span><span class="n">topCell</span><span class="o">.</span><span class="n">getNet</span><span class="p">(</span><span class="n">clk_net</span><span class="o">.</span><span class="n">getName</span><span class="p">())</span><span class="o">.</span><span class="n">getPortInsts</span><span class="p">()</span><span class="o">.</span><span class="n">toArray</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>                              
</code></pre></div></div>

<p>The routine takes the <strong>Design</strong> as its input, updates it directly and does not return anything.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">createBUFHs</span><span class="p">(</span><span class="n">design</span><span class="p">):</span>                     
</code></pre></div></div>

<p>Given the <strong>Design</strong>, we get its <strong>EDIFCell</strong> <code class="highlighter-rouge">topCell</code> and a list of <strong>Site</strong>s that contain the <code class="highlighter-rouge">BUFHCE</code> <strong>BEL</strong>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">topCell</span> <span class="o">=</span> <span class="n">design</span><span class="o">.</span><span class="n">getNetlist</span><span class="p">()</span><span class="o">.</span><span class="n">getTopCell</span><span class="p">()</span>
    <span class="n">bufhce_sites</span> <span class="o">=</span>  <span class="n">design</span><span class="o">.</span><span class="n">getDevice</span><span class="p">()</span><span class="o">.</span><span class="n">getAllCompatibleSites</span><span class="p">(</span><span class="n">SiteTypeEnum</span><span class="o">.</span><span class="n">BUFHCE</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>                 
</code></pre></div></div>

<p>We then set up a nested loop which iterates over each <code class="highlighter-rouge">BUFGCTRL</code> driven <strong>Net</strong>, and then each sink <strong>SitePin</strong> in that <strong>Net</strong>. If a design has more than one clock inputs, we would need to keep track of and remove any used <code class="highlighter-rouge">BUFHCE</code> from <code class="highlighter-rouge">bufhce_sites</code> after each outer loop iteration. Here, we’ve skipped it since our design only has one clock input.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">for</span> <span class="n">clk_net</span> <span class="ow">in</span> <span class="n">get_main_clock_nets</span><span class="p">(</span><span class="n">design</span><span class="p">):</span>
        <span class="n">pins</span> <span class="o">=</span> <span class="n">clk_net</span><span class="o">.</span><span class="n">getSinkPins</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pins</span><span class="p">)):</span>         
</code></pre></div></div>

<p>For each <code class="highlighter-rouge">pin</code>, we get its <strong>Site</strong> and then call the <code class="highlighter-rouge">closestSite()</code> routine. From the returned tuple, we can get the target <code class="highlighter-rouge">BUFHCE</code> <strong>Site</strong>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="n">pin</span> <span class="o">=</span> <span class="n">pins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">pin_site</span> <span class="o">=</span> <span class="n">pin</span><span class="o">.</span><span class="n">getSite</span><span class="p">()</span>
            <span class="n">bufhce_site</span> <span class="o">=</span> <span class="n">closestSite</span><span class="p">(</span><span class="n">pin_site</span><span class="p">,</span><span class="n">bufhce_sites</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>                    
</code></pre></div></div>

<p>Before we create a new <strong>Cell</strong>, we need to check if it already exists for the <code class="highlighter-rouge">BUFHCE</code> at <code class="highlighter-rouge">bufhce_site</code>. The naming convention we are using for our <code class="highlighter-rouge">BUGHCE</code> <strong>Cell</strong>s is “&lt; <strong>Net</strong>-name &gt;_bufhce_&lt; sink-pin-loop-index &gt;”. We initially set <code class="highlighter-rouge">exists</code> to be <code class="highlighter-rouge">-1</code>. For each pin that we have looped over thus far in the <strong>Net</strong>, we check to see if the <code class="highlighter-rouge">BUFHCE</code> <strong>Cell</strong> for it has been created. If true, then we check if the <strong>Site</strong> for this <strong>Cell</strong> matches our target <strong>Site</strong> <code class="highlighter-rouge">bufhce_site</code>. If there is a match, we overwrite <code class="highlighter-rouge">exists</code> with the matched index.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="n">exists</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">design</span><span class="o">.</span><span class="n">getCell</span><span class="p">(</span><span class="n">clk_net</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">+</span> <span class="s">"_bufhce_"</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">design</span><span class="o">.</span><span class="n">getCell</span><span class="p">(</span><span class="n">clk_net</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">+</span> <span class="s">"_bufhce_"</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">))</span><span class="o">.</span><span class="n">getSite</span><span class="p">())</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">bufhce_site</span><span class="p">):</span>
                        <span class="n">exists</span> <span class="o">=</span> <span class="n">j</span>                 
</code></pre></div></div>

<p>If no match was found, <code class="highlighter-rouge">exists</code> remains <code class="highlighter-rouge">-1</code> and we need to do the following:</p>

<ol>
  <li>Create a location string <code class="highlighter-rouge">loc</code> using the <strong>Site</strong> and <strong>BEL</strong> name. In this case, <strong>Site</strong> is <code class="highlighter-rouge">bufhce_site</code> and it will only have a single <code class="highlighter-rouge">BUFHCE</code> <strong>BEL</strong>.</li>
  <li>Create and place a new <strong>Cell</strong> at this location using the naming convention shown earlier.</li>
  <li>Connect (but not route) the chip enable pin <code class="highlighter-rouge">CE</code> for this <strong>Cell</strong> to <code class="highlighter-rouge">VCC</code>.</li>
  <li>Add <strong>SitePIP</strong>.</li>
  <li>Route <strong>SiteInst</strong>.</li>
  <li>Create a new <strong>Net</strong> using the inner loop index.</li>
  <li>Remove the current <code class="highlighter-rouge">pin</code> from the <code class="highlighter-rouge">BUFGCTRL</code> <strong>Net</strong>.</li>
  <li>Add the input pin <code class="highlighter-rouge">I</code> of the <code class="highlighter-rouge">BUFHCE</code> <strong>Cell</strong> to the <code class="highlighter-rouge">BUFGCTRL</code> <strong>Net</strong>.</li>
  <li>Add the output pin <code class="highlighter-rouge">O</code> of the <code class="highlighter-rouge">BUFHCE</code> <strong>Cell</strong> to the new <code class="highlighter-rouge">BUFHCE</code> <strong>Net</strong>.</li>
  <li>Add <code class="highlighter-rouge">pin</code> to the new <code class="highlighter-rouge">BUFHCE</code> <strong>Net</strong>.</li>
</ol>

<p>At this point, we’ve made changes to the physical netlist. Let’s reflect these changes in the logical netlist as well.</p>

<ol>
  <li>Create a new <strong>EDIFPortInst</strong> for the output pin of <code class="highlighter-rouge">BUFHCE</code> and add it to the <strong>EDIFNet</strong> corresponding to the new <code class="highlighter-rouge">BUFHCE</code> <strong>Net</strong>. Note that we did not need to create the <strong>EDIFNet</strong> as this was done automatically when we created the <strong>Net</strong>.</li>
  <li>Add the <strong>EDIFPortInst</strong> for the <code class="highlighter-rouge">pin</code> to this <strong>EDIFNet</strong>. How do we find this <strong>EDIFPortInst</strong>? Since we created the physical <strong>Net</strong>s directly from <strong>EDIFNet</strong>s, the ordering of <code class="highlighter-rouge">pins</code> and <strong>EDIFPortInst</strong>s should be the same. Moreover, we know that the <code class="highlighter-rouge">getPortInsts()</code> routine will list input <strong>EDIFPortInst</strong>s first. Finally, we also know that once we have added an <strong>EDIFPortInst</strong> to the new <strong>EDIFNet</strong>, we will be removing it later. Using these three pieces of information, we get a list of <strong>EDIFPortInst</strong>s in the <code class="highlighter-rouge">BUFGCTRL</code> <strong>EDIFNet</strong> and then get the first element in this list.</li>
  <li>Create a new <strong>EDIFPortInst</strong> for the input pin of <code class="highlighter-rouge">BUFHCE</code> and add it to the <strong>EDIFNet</strong> corresponding to the <code class="highlighter-rouge">BUFGCTRL</code> <strong>Net</strong>.</li>
  <li>Remove the first element in the list returned by <code class="highlighter-rouge">getPortInsts()</code> for the <code class="highlighter-rouge">BUFGCTRL</code> <strong>EDIFNet</strong>.</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="k">if</span> <span class="n">exists</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">bufhce_site</span><span class="p">)</span> <span class="o">+</span><span class="s">"/BUFHCE"</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">design</span><span class="o">.</span><span class="n">createAndPlaceCell</span><span class="p">(</span><span class="n">clk_net</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">+</span> <span class="s">"_bufhce_"</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="n">Unisim</span><span class="o">.</span><span class="n">BUFHCE</span><span class="p">,</span><span class="n">loc</span><span class="p">)</span> 
                <span class="n">ret</span><span class="o">.</span><span class="n">connectStaticSourceToPin</span><span class="p">(</span><span class="n">NetType</span><span class="o">.</span><span class="n">VCC</span> <span class="p">,</span><span class="s">"CE"</span><span class="p">)</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">getSiteInst</span><span class="p">()</span><span class="o">.</span><span class="n">addSitePIP</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">getSiteInst</span><span class="p">()</span><span class="o">.</span><span class="n">getSitePIP</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">getSiteInst</span><span class="p">()</span><span class="o">.</span><span class="n">getBEL</span><span class="p">(</span><span class="s">"CEINV"</span><span class="p">)</span><span class="o">.</span><span class="n">getPin</span><span class="p">(</span><span class="s">"CE"</span><span class="p">)))</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">getSiteInst</span><span class="p">()</span><span class="o">.</span><span class="n">routeSite</span><span class="p">()</span>
                <span class="n">net</span> <span class="o">=</span> <span class="n">design</span><span class="o">.</span><span class="n">createNet</span><span class="p">(</span><span class="n">clk_net</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                <span class="n">clk_net</span><span class="o">.</span><span class="n">removePin</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span>
                <span class="n">clk_net</span><span class="o">.</span><span class="n">addPin</span><span class="p">(</span><span class="n">SitePinInst</span><span class="p">(</span><span class="s">"I"</span><span class="p">,</span><span class="n">ret</span><span class="o">.</span><span class="n">getSiteInst</span><span class="p">()))</span>
                <span class="n">net</span><span class="o">.</span><span class="n">addPin</span><span class="p">(</span><span class="n">SitePinInst</span><span class="p">(</span><span class="s">"O"</span><span class="p">,</span><span class="n">ret</span><span class="o">.</span><span class="n">getSiteInst</span><span class="p">()))</span>
                <span class="n">net</span><span class="o">.</span><span class="n">addPin</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span>
                <span class="n">topCell</span><span class="o">.</span><span class="n">getNet</span><span class="p">(</span><span class="n">clk_net</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="o">.</span><span class="n">createPortInst</span><span class="p">(</span><span class="s">"O"</span><span class="p">,</span><span class="n">ret</span><span class="p">)</span>
                <span class="n">topCell</span><span class="o">.</span><span class="n">getNet</span><span class="p">(</span><span class="n">clk_net</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="o">.</span><span class="n">addPortInst</span><span class="p">(</span><span class="n">topCell</span><span class="o">.</span><span class="n">getNet</span><span class="p">(</span><span class="n">clk_net</span><span class="o">.</span><span class="n">getName</span><span class="p">())</span><span class="o">.</span><span class="n">getPortInsts</span><span class="p">()</span><span class="o">.</span><span class="n">toArray</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">topCell</span><span class="o">.</span><span class="n">getNet</span><span class="p">(</span><span class="n">clk_net</span><span class="o">.</span><span class="n">getName</span><span class="p">())</span><span class="o">.</span><span class="n">createPortInst</span><span class="p">(</span><span class="s">"I"</span><span class="p">,</span><span class="n">ret</span><span class="p">)</span>
                <span class="n">topCell</span><span class="o">.</span><span class="n">getNet</span><span class="p">(</span><span class="n">clk_net</span><span class="o">.</span><span class="n">getName</span><span class="p">())</span><span class="o">.</span><span class="n">removePortInst</span><span class="p">(</span><span class="n">topCell</span><span class="o">.</span><span class="n">getNet</span><span class="p">(</span><span class="n">clk_net</span><span class="o">.</span><span class="n">getName</span><span class="p">())</span><span class="o">.</span><span class="n">getPortInsts</span><span class="p">()</span><span class="o">.</span><span class="n">toArray</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>                 
</code></pre></div></div>

<p>If <code class="highlighter-rouge">exists</code> was updated, the <code class="highlighter-rouge">BUFHCE</code> <strong>Cell</strong>, its <strong>Net</strong> and its input/output <strong>EDIFPortInst</strong>s already exist. The only thing we need to do is add/remove pins and ports.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="k">else</span><span class="p">:</span>
                <span class="n">net</span> <span class="o">=</span> <span class="n">design</span><span class="o">.</span><span class="n">getNet</span><span class="p">(</span><span class="n">clk_net</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">exists</span><span class="p">))</span>
                <span class="n">clk_net</span><span class="o">.</span><span class="n">removePin</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span>
                <span class="n">net</span><span class="o">.</span><span class="n">addPin</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span>
                <span class="n">topCell</span><span class="o">.</span><span class="n">getNet</span><span class="p">(</span><span class="n">clk_net</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">exists</span><span class="p">))</span><span class="o">.</span><span class="n">addPortInst</span><span class="p">(</span><span class="n">topCell</span><span class="o">.</span><span class="n">getNet</span><span class="p">(</span><span class="n">clk_net</span><span class="o">.</span><span class="n">getName</span><span class="p">())</span><span class="o">.</span><span class="n">getPortInsts</span><span class="p">()</span><span class="o">.</span><span class="n">toArray</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">topCell</span><span class="o">.</span><span class="n">getNet</span><span class="p">(</span><span class="n">clk_net</span><span class="o">.</span><span class="n">getName</span><span class="p">())</span><span class="o">.</span><span class="n">removePortInst</span><span class="p">(</span><span class="n">topCell</span><span class="o">.</span><span class="n">getNet</span><span class="p">(</span><span class="n">clk_net</span><span class="o">.</span><span class="n">getName</span><span class="p">())</span><span class="o">.</span><span class="n">getPortInsts</span><span class="p">()</span><span class="o">.</span><span class="n">toArray</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>                              
</code></pre></div></div>

<h3 id="get-nets-driven-by-horizontal-clock-buffers-bufhce-for-7-series-fpgas">Get Nets Driven By Horizontal Clock Buffers (BUFHCE For 7-Series FPGAs)</h3>

<p>Now that we have two types of clock networks, let’s write the routine <code class="highlighter-rouge">get_secondary_clock_nets()</code> for returning all <code class="highlighter-rouge">BUFHCE</code> driven <strong>Net</strong>s.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_secondary_clock_nets</span><span class="p">(</span><span class="n">design</span><span class="p">):</span>
    <span class="n">nets</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">net</span> <span class="ow">in</span> <span class="n">design</span><span class="o">.</span><span class="n">getNets</span><span class="p">():</span>
        <span class="n">pins</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">getPins</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">pin</span> <span class="ow">in</span> <span class="n">pins</span><span class="p">:</span>
            <span class="n">bel_type</span> <span class="o">=</span> <span class="n">pin</span><span class="o">.</span><span class="n">getSite</span><span class="p">()</span><span class="o">.</span><span class="n">getSiteTypeEnum</span><span class="p">()</span><span class="o">.</span><span class="n">toString</span><span class="p">()</span>
            <span class="k">if</span> <span class="s">"BUFHCE"</span> <span class="ow">in</span> <span class="n">bel_type</span> <span class="ow">and</span> <span class="n">pin</span><span class="o">.</span><span class="n">isOutPin</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">net</span> <span class="ow">in</span> <span class="n">nets</span><span class="p">:</span>
                    <span class="n">nets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">net</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nets</span>
</code></pre></div></div>

<h3 id="routing-cost-function">Routing Cost Function</h3>

<p>Once we have finished setting up our <strong>Net</strong>s, we can now start working on routing them. The first step here is a cost function which operates on two <strong>RouteNode</strong>s. As we outlined eariler, <strong>RouteNode</strong>s keep track of the <em>Wires</em> and <em>PIPs</em> traversed. While both of our inputs are <strong>RouteNode</strong>s, only one is moving through the chip. The <code class="highlighter-rouge">snk</code> <strong>RouteNode</strong> is static: it represents the destination/sink of the connection. The <code class="highlighter-rouge">curr</code> <strong>RouteNode</strong>starts from the connection source and is the one that is moving. Note that we could also flip this in our routing and trace a path from sink to source.</p>

<p>The <code class="highlighter-rouge">BUFHCE</code> cost function earlier dealt with placement and hence a simple Manhattan distance computation was sufficient. Since we are now dealing with routing, something more complex is needed. In this case, we follow the RapidWright tutorial and factor in the number of “hops” done thus far by the <strong>RouteNode</strong> - given by the <code class="highlighter-rouge">getLevel()' routine. More "hops" can mean a longer route and high routing fabric resource usage, both of which we want to minimize. We do scale the </code>getLevel()` output so that it does not dominate the cost function too quickly.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">costFunction</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">snk</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">curr</span><span class="o">.</span><span class="n">getManhattanDistance</span><span class="p">(</span><span class="n">snk</span><span class="p">)</span> <span class="o">+</span> <span class="n">curr</span><span class="o">.</span><span class="n">getLevel</span><span class="p">()</span><span class="o">/</span><span class="mi">8</span>  
</code></pre></div></div>

<h3 id="find-route-between-two-routenode-objects-in-a-clock-net-object">Find Route Between Two RouteNode Objects In A Clock Net Object</h3>

<p>Next we write the routine <code class="highlighter-rouge">findRoute</code> which takes a sink <strong>RouteNode</strong> <code class="highlighter-rouge">snk</code> and a Priority Queue <code class="highlighter-rouge">q</code> of <strong>RouteNode</strong>s as input, and returns all <strong>PIP</strong>s traversed in a successful route. When the routine is called, <code class="highlighter-rouge">q</code> only has a single entry i.e. the source <strong>RouteNode</strong>. Before we start routing, we also instantiate a HashSet <code class="highlighter-rouge">visited</code> to keep track of already traversed fabric. Note that there typically would be third input to this routine: a list of all <strong>PIP</strong>s used by <strong>Net</strong>s that have already been routed. This list would ensure that <strong>Net</strong>s don’t cross each other. However, since we are effectively only routing a single signal, this can be skipped for now.</p>

<p>The overall goal here, while the Priority Queue is not empty, is to take the lowest cost entry in the Priority Queue and check if it matches with the sink <strong>RouteNode</strong>. If there is a match, we have successfully routed the signal and we call the <code class="highlighter-rouge">getPIPsBackToSource()</code> from the <code class="highlighter-rouge">curr</code> <strong>RouteNode</strong> to get the required <strong>PIP</strong>s. If there is no match, we create a new set of <strong>RouteNode</strong>s using the <code class="highlighter-rouge">curr</code> <strong>RouteNode</strong> and every <strong>Wire</strong> branching out from it. We then evalue the costs for these new <strong>RouteNode</strong>s and add them to the Priority Queue. Since these <strong>RouteNode</strong>s were created from <code class="highlighter-rouge">curr</code>, they will  automatically copy over all path encountered by <code class="highlighter-rouge">curr</code> and add it to their own local information.</p>

<p>If the Priority Queue empties out, the routing is deemed to have failed. Note that it is also possible to implement (and has been implemented in the RapidWright tutorial) a watchdog timer to support timeout functionality if routing is taking much longer than it should.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">findRoute</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">snk</span><span class="p">):</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="n">HashSet</span><span class="p">()</span>
    <span class="k">while</span><span class="p">(</span><span class="ow">not</span> <span class="n">q</span><span class="o">.</span><span class="n">isEmpty</span><span class="p">()):</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">poll</span><span class="p">()</span>
        <span class="k">if</span><span class="p">(</span><span class="n">curr</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">snk</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">curr</span><span class="o">.</span><span class="n">getPIPsBackToSource</span><span class="p">()</span>
        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">wire</span> <span class="ow">in</span> <span class="n">curr</span><span class="o">.</span><span class="n">getConnections</span><span class="p">():</span>
            <span class="n">nextNode</span> <span class="o">=</span> <span class="n">RouteNode</span><span class="p">(</span><span class="n">wire</span><span class="p">,</span><span class="n">curr</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">visited</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">nextNode</span><span class="p">):</span> <span class="k">continue</span>
            <span class="n">curr_cost</span> <span class="o">=</span> <span class="n">costFunction</span><span class="p">(</span><span class="n">nextNode</span><span class="p">,</span><span class="n">snk</span><span class="p">)</span>
            <span class="n">nextNode</span><span class="o">.</span><span class="n">setCost</span><span class="p">(</span><span class="n">curr_cost</span><span class="p">)</span>
            <span class="n">q</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">nextNode</span><span class="p">)</span>
    <span class="c1"># Unroutable situation
</span>    <span class="k">print</span> <span class="s">"Route failed!"</span>
    <span class="k">return</span> <span class="p">[]</span>
</code></pre></div></div>

<h3 id="route-individual-sinks-and-add-unique-pips-for-each-clock-net-object">Route Individual Sinks And Add Unique PIPs For Each Clock Net Object</h3>

<p>To drive the <code class="highlighter-rouge">findRoute()</code> routine, we write the <code class="highlighter-rouge">routeClockNet()</code> routine. <code class="highlighter-rouge">routeClockNet()</code>  takes as input a target <strong>Net</strong>, finds the list of <strong>PIPs</strong> in a successfully routed connection, and adds them to the <strong>Net</strong>. For each sink in this <strong>Net</strong>, we create a new Priority Queue and add the <strong>Net</strong> source’s <strong>RouteNode</strong> to it. This is followed by a call to <code class="highlighter-rouge">findRoute()</code>. The results of all <code class="highlighter-rouge">findRoute()</code> calls for this <strong>Net</strong> are stored in a list called <code class="highlighter-rouge">path</code>. Once we have processed all sinks, we then remove duplicate <strong>PIP</strong> entries in <code class="highlighter-rouge">path</code> and add it to the <strong>Net</strong> using the <code class="highlighter-rouge">setPIPs()</code> routine.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">routeClockNet</span><span class="p">(</span><span class="n">net</span><span class="p">):</span>
    <span class="n">path</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">sink</span> <span class="ow">in</span> <span class="n">net</span><span class="o">.</span><span class="n">getPins</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">sink</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">net</span><span class="o">.</span><span class="n">getSource</span><span class="p">()):</span> 
            <span class="k">continue</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">RouteNode</span><span class="o">.</span><span class="n">getPriorityQueue</span><span class="p">()</span>
        <span class="n">q</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">net</span><span class="o">.</span><span class="n">getSource</span><span class="p">()</span><span class="o">.</span><span class="n">getRouteNode</span><span class="p">())</span>
        <span class="n">path</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">findRoute</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">sink</span><span class="o">.</span><span class="n">getRouteNode</span><span class="p">()))</span> 
    <span class="n">path</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
    <span class="n">net</span><span class="o">.</span><span class="n">setPIPs</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">return</span>
</code></pre></div></div>

<h3 id="putting-it-all-together-1">Putting It All Together</h3>
<p>Now that we have all our routines, let’s put it all together in the <code class="highlighter-rouge">routeClocks()</code> routine.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">routeClocks</span><span class="p">(</span><span class="n">design</span><span class="p">):</span>
    <span class="n">createBUFHs</span><span class="p">(</span><span class="n">design</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">net</span> <span class="ow">in</span> <span class="n">get_main_clock_nets</span><span class="p">(</span><span class="n">design</span><span class="p">):</span>
        <span class="n">routeClockNet</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="n">usedPIPs</span><span class="p">)</span>        
    <span class="k">for</span> <span class="n">net</span> <span class="ow">in</span> <span class="n">get_secondary_clock_nets</span><span class="p">(</span><span class="n">design</span><span class="p">):</span>
        <span class="n">routeClockNet</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="n">usedPIPs</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="step-7-route-remaining-design-using-the-native-rapidwright-design-router">Step 7: Route Remaining Design Using The Native RapidWright Design Router</h2>
<p>To route the rest of the design, we need to call <code class="highlighter-rouge">routeDesign()</code> from the <strong>Router</strong> class. However, before we do that, we need to lock the clock routing to prevent it from getting overwritten. And once the remaining signals are routed, we will unlock the clock routing.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">designRouter</span><span class="p">(</span><span class="n">design</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">net</span> <span class="ow">in</span> <span class="n">get_main_clock_nets</span><span class="p">(</span><span class="n">design</span><span class="p">):</span>
        <span class="n">net</span><span class="o">.</span><span class="n">lockRouting</span><span class="p">()</span>   
    <span class="k">for</span> <span class="n">net</span> <span class="ow">in</span> <span class="n">get_secondary_clock_nets</span><span class="p">(</span><span class="n">design</span><span class="p">):</span>
        <span class="n">net</span><span class="o">.</span><span class="n">lockRouting</span><span class="p">()</span>               
    <span class="n">Router</span><span class="p">(</span><span class="n">design</span><span class="p">)</span><span class="o">.</span><span class="n">routeDesign</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">net</span> <span class="ow">in</span> <span class="n">get_main_clock_nets</span><span class="p">(</span><span class="n">design</span><span class="p">):</span>
        <span class="n">net</span><span class="o">.</span><span class="n">unlockRouting</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">net</span> <span class="ow">in</span> <span class="n">get_secondary_clock_nets</span><span class="p">(</span><span class="n">design</span><span class="p">):</span>
        <span class="n">net</span><span class="o">.</span><span class="n">unlockRouting</span><span class="p">()</span>
</code></pre></div></div>

<h2 id="step-8-fasm-generator">Step 8: FASM Generator</h2>
<p>At this point, we have a placed and routed design. The final piece is generating the bitstream using an open source tool such as <a href="https://github.com/SymbiFlow/prjxray">Project Xray</a>. Doing so requires writing out a <code class="highlighter-rouge">.fasm</code> file which maps the physical netlist we just created to the specific FPGA configuration memory bits that must be set.</p>

<p>Currently, this is still a work in process. We have provided an algorithm for it in the accompanying Jupyter Notebook file that can successfully map <em>LUTs</em> (including route-through <em>LUTs</em>), <em>FDREs</em>, <em>IO BUFs</em> and most signals. It is, however, unable to reliably map clock nets and bi-directional <strong>PIPs</strong>. As a result, for now we will use Vivado for bitstream generation.</p>

<h2 id="step-9-the-overall-rapidwright-flow">Step 9: The Overall RapidWright Flow</h2>
<p>In this Step, we will put together the overall RapidWright flow using everything we have built thus far.</p>

<h3 id="some-more-imports-1">Some More Imports</h3>
<p>We begin by importing some more Classes.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">os</span>
</code></pre></div></div>

<h3 id="putting-our-rapidwright-routines-together">Putting Our RapidWright Routines Together</h3>
<p>The <code class="highlighter-rouge">run_rapidwright</code> requires a seed for random number generation (<code class="highlighter-rouge">seed</code>), the name of our <strong>EDIFCell</strong> (<code class="highlighter-rouge">topModule</code>), the device name (<code class="highlighter-rouge">device</code>), the JSON Yosys output (<code class="highlighter-rouge">filename</code>) and our design constraints (<code class="highlighter-rouge">constraints</code>). <code class="highlighter-rouge">run_rapidwright</code> does the following operations:</p>

<ol>
  <li>Set the random number generation seed.</li>
  <li>Read the Yosys JSON file and build a logical netlsit.</li>
  <li>Get the <strong>EDIFNetlist</strong> and <strong>EDIFCell</strong> for the design.</li>
  <li>Place I/O buffers using user defined constraints.</li>
  <li>Place <strong>Cell</strong>s.</li>
  <li>Create <strong>Net</strong>s and <strong>SitePinInst</strong>s in these <strong>Net</strong>s.</li>
  <li>Add and route <strong>SitePIPs</strong>.</li>
  <li>Run <code class="highlighter-rouge">routeSites()</code> again, but this time for the overall design instead of for a particular <strong>SiteInst</strong> - this was able to route the <strong>SitePIP</strong>s in the IO Buffers.</li>
  <li>Route clocks in the design.</li>
</ol>

<p>Since the routing can fail for certain seed values, we do the rest in a try block.</p>

<ol>
  <li>Run the native RapidWright design router.</li>
  <li>Map the physical netlist to FPGA configuration memory and write out the <code class="highlighter-rouge">.fasm</code> file.</li>
  <li>Write out a <code class="highlighter-rouge">.dcp</code> design checkpoint file that is used by Vivado to import the placed and routed design.</li>
  <li>If everything was successful, return <code class="highlighter-rouge">1</code>. Else, return <code class="highlighter-rouge">0</code>.</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">run_rapidwright</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">topModule</span><span class="p">,</span><span class="n">device</span><span class="p">,</span><span class="n">filename</span><span class="p">,</span><span class="n">constraints</span><span class="p">):</span>
    <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="n">design</span> <span class="o">=</span> <span class="n">read_json</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="n">topModule</span><span class="p">,</span><span class="n">device</span><span class="p">)</span>
    <span class="n">net</span> <span class="o">=</span> <span class="n">design</span><span class="o">.</span><span class="n">getNetlist</span><span class="p">()</span>
    <span class="n">net</span><span class="o">.</span><span class="n">setDevice</span><span class="p">(</span><span class="n">design</span><span class="o">.</span><span class="n">getDevice</span><span class="p">())</span>
    <span class="n">topCell</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">getCell</span><span class="p">(</span><span class="s">"top"</span><span class="p">)</span>
    <span class="n">placeIOBuffers</span><span class="p">(</span><span class="n">design</span> <span class="p">,</span> <span class="n">constraints</span><span class="p">)</span>
    <span class="n">placeCells</span><span class="p">(</span><span class="n">design</span><span class="p">)</span>
    <span class="n">createNets</span><span class="p">(</span><span class="n">design</span><span class="p">)</span>
    <span class="n">createNetPins</span><span class="p">(</span><span class="n">design</span><span class="p">)</span>
    <span class="n">routeSitePIPs</span><span class="p">(</span><span class="n">design</span><span class="p">)</span>
    <span class="n">design</span><span class="o">.</span><span class="n">routeSites</span><span class="p">()</span> 
    <span class="n">routeClocks</span><span class="p">(</span><span class="n">design</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">designRouter</span><span class="p">(</span><span class="n">design</span><span class="p">)</span>
        <span class="n">write_fasm</span><span class="p">(</span><span class="n">design</span><span class="p">)</span>
        <span class="n">design</span><span class="o">.</span><span class="n">writeCheckpoint</span><span class="p">(</span><span class="n">topModule</span><span class="o">+</span><span class="s">".dcp"</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
</code></pre></div></div>

<h3 id="running-rapidwright">Running RapidWright</h3>
<p>And finally, call <code class="highlighter-rouge">run_rapidwright</code> with incrementing seed values till the routine returns <code class="highlighter-rouge">1</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">run_rapidwright</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">topModule</span><span class="p">,</span><span class="n">device</span><span class="p">,</span><span class="n">filename</span><span class="p">,</span><span class="n">constraints</span><span class="p">)):</span>
        <span class="k">print</span> <span class="s">"Seed Value: "</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">break</span>
</code></pre></div></div>

<h2 id="step-10-the-overall-synthesis--pr--bitstream-generation-flow">Step 10: The Overall Synthesis + P&amp;R + Bitstream Generation Flow</h2>
<p>In the last step, let’s combine all the separate flows into one routine.</p>

<h3 id="run-yosys">Run Yosys</h3>
<p>We run Yosys from within the Jupyter Notebook using the command discussed earlier.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">run_yosys</span><span class="p">(</span><span class="n">topModule</span><span class="p">):</span>
    <span class="n">yosys_cmd</span> <span class="o">=</span> <span class="s">"""yosys -p "synth_xilinx -flatten -abc9 -nobram -arch xc7 -top """</span><span class="o">+</span><span class="n">topModule</span><span class="o">+</span><span class="s">"""; write_json """</span><span class="o">+</span><span class="n">topModule</span><span class="o">+</span><span class="s">""".json" """</span><span class="o">+</span><span class="n">topModule</span><span class="o">+</span><span class="s">""".v"""</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="n">yosys_cmd</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="generate-bitstream-using-project-xray">Generate Bitstream Using Project XRAY</h3>
<p>If we are using Project XRAY for bitstream generation, we would need to call the following functions to generate the bitstream for our target Arty FPGA.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">${</span><span class="nv">XRAY_UTILS_DIR</span><span class="k">}</span>/fasm2frames.py <span class="nt">--part</span> xc7a35tcsg324-1 <span class="nt">--db-root</span> <span class="k">${</span><span class="nv">XRAY_UTILS_DIR</span><span class="k">}</span>/../database/artix7 top.fasm <span class="o">&gt;</span> top.frames

<span class="k">${</span><span class="nv">XRAY_TOOLS_DIR</span><span class="k">}</span>/xc7frames2bit <span class="nt">--part_file</span> <span class="k">${</span><span class="nv">XRAY_UTILS_DIR</span><span class="k">}</span>/../database/artix7/xc7a35tcsg324-1/part.yaml <span class="nt">--part_name</span> xc7a35tcsg324-1  <span class="nt">--frm_file</span> top.frames <span class="nt">--output_file</span> top.bit
</code></pre></div></div>

<h3 id="generate-bitstream-using-vivado">Generate Bitstream Using Vivado</h3>
<p>If we are using Vivado for bitstream generation, we need to call the <code class="highlighter-rouge">write_bitstream</code> tcl command. We do not need to make a Vivado project for this. Instead, we first create a tcl script that will open the design checkpoint and write the bitstream, and then call Vivado without opening its GUI (assuming it has been added to <code class="highlighter-rouge">PATH</code>).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">generate_vivado_bistream</span><span class="p">(</span><span class="n">topModule</span><span class="p">):</span>
    <span class="n">tcl_code</span><span class="o">=</span><span class="s">"""
    open_checkpoint """</span><span class="o">+</span><span class="n">topModule</span><span class="o">+</span><span class="s">""".dcp
    write_bitstream -force """</span><span class="o">+</span><span class="n">topModule</span><span class="o">+</span><span class="s">"""
    """</span>
    <span class="n">tcl_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">topModule</span><span class="o">+</span><span class="s">".tcl"</span><span class="p">,</span><span class="s">"w"</span><span class="p">)</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">tcl_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">tcl_code</span><span class="p">)</span>
    <span class="n">tcl_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">vivado_cmd</span> <span class="o">=</span> <span class="s">"""vivado vivado_files/"""</span><span class="o">+</span><span class="n">topModule</span><span class="o">+</span><span class="s">""".xpr -nolog -nojournal -notrace -mode batch -source """</span><span class="o">+</span><span class="n">topModule</span><span class="o">+</span><span class="s">""".tcl"""</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="n">vivado_cmd</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="putting-it-all-together-2">Putting It All Together</h3>

<p>The final <code class="highlighter-rouge">main()</code> routine looks like this:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">run_yosys</span><span class="p">(</span><span class="n">topModule</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">run_rapidwright</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">topModule</span><span class="p">,</span><span class="n">device</span><span class="p">,</span><span class="n">filename</span><span class="p">,</span><span class="n">constraints</span><span class="p">)):</span>
        <span class="k">print</span> <span class="s">"Seed Value: "</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">break</span>

<span class="n">generate_vivado_bistream</span><span class="p">(</span><span class="n">topModule</span><span class="p">)</span>
<span class="k">print</span> <span class="s">"Done"</span>
</code></pre></div></div>

<h2 id="step-11-programming-the-bitstream-using-openocd">Step 11: Programming The Bitstream Using OpenOCD</h2>
<p>In the spirit of maximizing the use of open source tools, let’s limit the use of Vivado to just bitstream generation and use another tool for programming. OpenOCD is one such tool that provides the JTAG capabilities needed to program the FPGA. It can be installed using:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>dnf <span class="nb">install </span>openocd
</code></pre></div></div>

<p>or built from source using:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">tar</span> <span class="nt">-xf</span> openocd-0.10.0.tar.bz2
<span class="nb">cd </span>openocd-0.10.0
./configure  <span class="nt">--enable-ft2232_libftdi</span> <span class="nt">--enable-libusb0</span> <span class="nt">--disable-werror</span>
make
<span class="nb">sudo </span>make <span class="nb">install</span>
</code></pre></div></div>

<p>OpenOCD requires a device configuration file before it can program the device. The following is the configuration file <code class="highlighter-rouge">top.cfg</code> for Digilent Arty A7-35t.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>interface ftdi
ftdi_device_desc <span class="s2">"Digilent USB Device"</span>
ftdi_vid_pid 0x0403 0x6010
ftdi_channel 0
ftdi_layout_init 0x0088 0x008b
reset_config none
adapter_khz 10000
<span class="nb">source</span> <span class="o">[</span>find cpld/xilinx-xc7.cfg]
</code></pre></div></div>

<p>And with that set up, we can go ahead and program the device with our bitstream.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>openocd <span class="nt">-f</span> top.cfg  <span class="nt">-c</span> <span class="s2">"init; pld load 0 top.bit; exit"</span>
</code></pre></div></div>

						</article>
			</section>

		<!-- Footer -->
			<footer id="footer">
				<div class="inner">


					<div class="copyright">
						&copy; Design adapted from: <a href="https://templated.co">TEMPLATED</a>
					</div>

				</div>
			</footer>

		<!-- Scripts -->
			<script src="/assets/js/jquery.min.js"></script>
			<script src="/assets/js/skel.min.js"></script>
			<script src="/assets/js/util.js"></script>
			<script src="/assets/js/main.js"></script>

	</body>
</html>

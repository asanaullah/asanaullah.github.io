I"≠<p>Programmability is one of the biggest challenges for specialized hardware, faced by software and hardware developers alike. Writing code for high quality hardware using a Hardware Description Language (HDL) requires both time and expertise due to limited abstractions, akin to assembly languages in CPUs and GPUs.</p>

<p>High Level Synthesis (HLS) provides an alternative to HDL programming by enabling designs to be expressed with (familiar) high level languages, such as ‚ÄòC‚Äô, which is then compiled to HDL code. This is similar to the front-end of compilers for software languages, in that HLS compilers parse high level language code, generate IR code, and do a number of optimization passes on this IR code. Developers can guide the optimization passes by annotating the source code to indicate where, how and to what degree parallelism can be exploited.</p>

<p>Despite the advantages of HLS and the advances made in recent years in this field, we are still far from the same levels of productivity as with compilers for software languages. This is because of two major challenges.</p>

<p>The first challenge stems from the optimization passes done by HLS compilers, and is referred to as the Performance-Portability problem. In a nutshell, the Performance-Portability problem means it is possible to write high level language code that performs well for either FPGAs or CPUs/GPUs as long as we tailor the code to target a specific platform - in general so far, it is not possible to have high-level code which executes well on all platforms. This is because of the limitations of the semantics of high level languages. Even with annotations, it is not possible for HLS compilers to reliably derive sufficient information about the target circuit from CPU/GPU source code in an acceptable time frame. To achieve good results, the source code must be manually restructured to help the compiler detect design patterns that map well to hardware, i.e. losing portability to get performance. ‚ÄúUnified‚Äù languages and APIs for heterogeneous compute environments can help overcome the semantic limitations of traditional languages, but it may not  be practical to port over decades worth of existing code.</p>

:ET